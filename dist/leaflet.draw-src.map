{"version":3,"sources":["src/Leaflet.draw.js","src/Leaflet.Draw.Event.js","src/draw/handler/Draw.Feature.js","src/draw/handler/Draw.Polyline.js","src/draw/handler/Draw.Polygon.js","src/draw/handler/Draw.SimpleShape.js","src/draw/handler/Draw.Rectangle.js","src/draw/handler/Draw.Marker.js","src/draw/handler/Draw.CircleMarker.js","src/draw/handler/Draw.Circle.js","src/edit/handler/Edit.Marker.js","src/edit/handler/Edit.Poly.js","src/edit/handler/Edit.SimpleShape.js","src/edit/handler/Edit.Rectangle.js","src/edit/handler/Edit.CircleMarker.js","src/edit/handler/Edit.Circle.js","src/ext/TouchEvents.js","src/ext/LatLngUtil.js","src/ext/GeometryUtil.js","src/ext/LineUtil.Intersect.js","src/ext/Polyline.Intersect.js","src/ext/Polygon.Intersect.js","src/Control.Draw.js","src/Toolbar.js","src/Tooltip.js","src/draw/DrawToolbar.js","src/edit/EditToolbar.js","src/edit/handler/EditToolbar.Edit.js","src/edit/handler/EditToolbar.Delete.js"],"names":[],"mappings":";;;;;;;yCAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\r\n * Leaflet.draw assumes that you have already included the Leaflet library.\r\n */\r\nL.drawVersion = \"1.0.3+638b962\";\r\n/**\r\n * @class L.Draw\r\n * @aka Draw\r\n *\r\n *\r\n * To add the draw toolbar set the option drawControl: true in the map options.\r\n *\r\n * @example\r\n * ```js\r\n *      var map = L.map('map', {drawControl: true}).setView([51.505, -0.09], 13);\r\n *\r\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\r\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n *      }).addTo(map);\r\n * ```\r\n *\r\n * ### Adding the edit toolbar\r\n * To use the edit toolbar you must initialise the Leaflet.draw control and manually add it to the map.\r\n *\r\n * ```js\r\n *      var map = L.map('map').setView([51.505, -0.09], 13);\r\n *\r\n *      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {\r\n *          attribution: '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n *      }).addTo(map);\r\n *\r\n *      // FeatureGroup is to store editable layers\r\n *      var drawnItems = new L.FeatureGroup();\r\n *      map.addLayer(drawnItems);\r\n *\r\n *      var drawControl = new L.Control.Draw({\r\n *          edit: {\r\n *              featureGroup: drawnItems\r\n *          }\r\n *      });\r\n *      map.addControl(drawControl);\r\n * ```\r\n *\r\n * The key here is the featureGroup option. This tells the plugin which FeatureGroup contains the layers that\r\n * should be editable. The featureGroup can contain 0 or more features with geometry types Point, LineString, and Polygon.\r\n * Leaflet.draw does not work with multigeometry features such as MultiPoint, MultiLineString, MultiPolygon,\r\n * or GeometryCollection. If you need to add multigeometry features to the draw plugin, convert them to a\r\n * FeatureCollection of non-multigeometries (Points, LineStrings, or Polygons).\r\n */\r\nL.Draw = {};\r\n\r\n/**\r\n * @class L.drawLocal\r\n * @aka L.drawLocal\r\n *\r\n * The core toolbar class of the API — it is used to create the toolbar ui\r\n *\r\n * @example\r\n * ```js\r\n *      var modifiedDraw = L.drawLocal.extend({\r\n *          draw: {\r\n *              toolbar: {\r\n *                  buttons: {\r\n *                      polygon: 'Draw an awesome polygon'\r\n *                  }\r\n *              }\r\n *          }\r\n *      });\r\n * ```\r\n *\r\n * The default state for the control is the draw toolbar just below the zoom control.\r\n *  This will allow map users to draw vectors and markers.\r\n *  **Please note the edit toolbar is not enabled by default.**\r\n */\r\nL.drawLocal = {\r\n\t// format: {\r\n\t// \tnumeric: {\r\n\t// \t\tdelimiters: {\r\n\t// \t\t\tthousands: ',',\r\n\t// \t\t\tdecimal: '.'\r\n\t// \t\t}\r\n\t// \t}\r\n\t// },\r\n\tdraw: {\r\n\t\ttoolbar: {\r\n\t\t\t// #TODO: this should be reorganized where actions are nested in actions\r\n\t\t\t// ex: actions.undo  or actions.cancel\r\n\t\t\tactions: {\r\n\t\t\t\ttitle: 'Cancel drawing',\r\n\t\t\t\ttext: 'Cancel'\r\n\t\t\t},\r\n\t\t\tfinish: {\r\n\t\t\t\ttitle: 'Finish drawing',\r\n\t\t\t\ttext: 'Finish'\r\n\t\t\t},\r\n\t\t\tundo: {\r\n\t\t\t\ttitle: 'Delete last point drawn',\r\n\t\t\t\ttext: 'Delete last point'\r\n\t\t\t},\r\n\t\t\tbuttons: {\r\n\t\t\t\tpolyline: 'Draw a polyline',\r\n\t\t\t\tpolygon: 'Draw a polygon',\r\n\t\t\t\trectangle: 'Draw a rectangle',\r\n\t\t\t\tcircle: 'Draw a circle',\r\n\t\t\t\tmarker: 'Draw a marker',\r\n\t\t\t\tcirclemarker: 'Draw a circlemarker'\r\n\t\t\t}\r\n\t\t},\r\n\t\thandlers: {\r\n\t\t\tcircle: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click and drag to draw circle.'\r\n\t\t\t\t},\r\n\t\t\t\tradius: 'Radius'\r\n\t\t\t},\r\n\t\t\tcirclemarker: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click map to place circle marker.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmarker: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click map to place marker.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tpolygon: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click to start drawing shape.',\r\n\t\t\t\t\tcont: 'Click to continue drawing shape.',\r\n\t\t\t\t\tend: 'Click first point to close this shape.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tpolyline: {\r\n\t\t\t\terror: '<strong>Error:</strong> shape edges cannot cross!',\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click to start drawing line.',\r\n\t\t\t\t\tcont: 'Click to continue drawing line.',\r\n\t\t\t\t\tend: 'Click last point to finish line.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\trectangle: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tstart: 'Click and drag to draw rectangle.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsimpleshape: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\tend: 'Release mouse to finish drawing.'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tedit: {\r\n\t\ttoolbar: {\r\n\t\t\tactions: {\r\n\t\t\t\tsave: {\r\n\t\t\t\t\ttitle: 'Save changes',\r\n\t\t\t\t\ttext: 'Save'\r\n\t\t\t\t},\r\n\t\t\t\tcancel: {\r\n\t\t\t\t\ttitle: 'Cancel editing, discards all changes',\r\n\t\t\t\t\ttext: 'Cancel'\r\n\t\t\t\t},\r\n\t\t\t\tclearAll: {\r\n\t\t\t\t\ttitle: 'Clear all layers',\r\n\t\t\t\t\ttext: 'Clear All'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tbuttons: {\r\n\t\t\t\tedit: 'Edit layers',\r\n\t\t\t\teditDisabled: 'No layers to edit',\r\n\t\t\t\tremove: 'Delete layers',\r\n\t\t\t\tremoveDisabled: 'No layers to delete'\r\n\t\t\t}\r\n\t\t},\r\n\t\thandlers: {\r\n\t\t\tedit: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\ttext: 'Drag handles or markers to edit features.',\r\n\t\t\t\t\tsubtext: 'Click cancel to undo changes.'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tremove: {\r\n\t\t\t\ttooltip: {\r\n\t\t\t\t\ttext: 'Click on a feature to remove.'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n","/**\r\n * ### Events\r\n * Once you have successfully added the Leaflet.draw plugin to your map you will want to respond to the different\r\n * actions users can initiate. The following events will be triggered on the map:\r\n *\r\n * @class L.Draw.Event\r\n * @aka Draw.Event\r\n *\r\n * Use `L.Draw.Event.EVENTNAME` constants to ensure events are correct.\r\n *\r\n * @example\r\n * ```js\r\n * map.on(L.Draw.Event.CREATED; function (e) {\r\n *    var type = e.layerType,\r\n *        layer = e.layer;\r\n *\r\n *    if (type === 'marker') {\r\n *        // Do marker specific actions\r\n *    }\r\n *\r\n *    // Do whatever else you need to. (save to db; add to map etc)\r\n *    map.addLayer(layer);\r\n *});\r\n * ```\r\n */\r\nL.Draw.Event = {};\r\n/**\r\n * @event draw:created: PolyLine; Polygon; Rectangle; Circle; Marker | String\r\n *\r\n * Layer that was just created.\r\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\r\n * Triggered when a new vector or marker has been created.\r\n *\r\n */\r\nL.Draw.Event.CREATED = 'draw:created';\r\n\r\n/**\r\n * @event draw:edited: LayerGroup\r\n *\r\n * List of all layers just edited on the map.\r\n *\r\n *\r\n * Triggered when layers in the FeatureGroup; initialised with the plugin; have been edited and saved.\r\n *\r\n * @example\r\n * ```js\r\n *      map.on('draw:edited', function (e) {\r\n     *          var layers = e.layers;\r\n     *          layers.eachLayer(function (layer) {\r\n     *              //do whatever you want; most likely save back to db\r\n     *          });\r\n     *      });\r\n * ```\r\n */\r\nL.Draw.Event.EDITED = 'draw:edited';\r\n\r\n/**\r\n * @event draw:deleted: LayerGroup\r\n *\r\n * List of all layers just removed from the map.\r\n *\r\n * Triggered when layers have been removed (and saved) from the FeatureGroup.\r\n */\r\nL.Draw.Event.DELETED = 'draw:deleted';\r\n\r\n/**\r\n * @event draw:drawstart: String\r\n *\r\n * The type of layer this is. One of:`polyline`; `polygon`; `rectangle`; `circle`; `marker`\r\n *\r\n * Triggered when the user has chosen to draw a particular vector or marker.\r\n */\r\nL.Draw.Event.DRAWSTART = 'draw:drawstart';\r\n\r\n/**\r\n * @event draw:drawstop: String\r\n *\r\n * The type of layer this is. One of: `polyline`; `polygon`; `rectangle`; `circle`; `marker`\r\n *\r\n * Triggered when the user has finished a particular vector or marker.\r\n */\r\n\r\nL.Draw.Event.DRAWSTOP = 'draw:drawstop';\r\n\r\n/**\r\n * @event draw:drawvertex: LayerGroup\r\n *\r\n * List of all layers just being added from the map.\r\n *\r\n * Triggered when a vertex is created on a polyline or polygon.\r\n */\r\nL.Draw.Event.DRAWVERTEX = 'draw:drawvertex';\r\n\r\n/**\r\n * @event draw:editstart: String\r\n *\r\n * The type of edit this is. One of: `edit`\r\n *\r\n * Triggered when the user starts edit mode by clicking the edit tool button.\r\n */\r\n\r\nL.Draw.Event.EDITSTART = 'draw:editstart';\r\n\r\n/**\r\n * @event draw:editmove: ILayer\r\n *\r\n *  Layer that was just moved.\r\n *\r\n * Triggered as the user moves a rectangle; circle or marker.\r\n */\r\nL.Draw.Event.EDITMOVE = 'draw:editmove';\r\n\r\n/**\r\n * @event draw:editresize: ILayer\r\n *\r\n * Layer that was just moved.\r\n *\r\n * Triggered as the user resizes a rectangle or circle.\r\n */\r\nL.Draw.Event.EDITRESIZE = 'draw:editresize';\r\n\r\n/**\r\n * @event draw:editvertex: LayerGroup\r\n *\r\n * List of all layers just being edited from the map.\r\n *\r\n * Triggered when a vertex is edited on a polyline or polygon.\r\n */\r\nL.Draw.Event.EDITVERTEX = 'draw:editvertex';\r\n\r\n/**\r\n * @event draw:editstop: String\r\n *\r\n * The type of edit this is. One of: `edit`\r\n *\r\n * Triggered when the user has finshed editing (edit mode) and saves edits.\r\n */\r\nL.Draw.Event.EDITSTOP = 'draw:editstop';\r\n\r\n/**\r\n * @event draw:deletestart: String\r\n *\r\n * The type of edit this is. One of: `remove`\r\n *\r\n * Triggered when the user starts remove mode by clicking the remove tool button.\r\n */\r\nL.Draw.Event.DELETESTART = 'draw:deletestart';\r\n\r\n/**\r\n * @event draw:deletestop: String\r\n *\r\n * The type of edit this is. One of: `remove`\r\n *\r\n * Triggered when the user has finished removing shapes (remove mode) and saves.\r\n */\r\nL.Draw.Event.DELETESTOP = 'draw:deletestop';\r\n\r\n/**\r\n * @event draw:toolbaropened: String\r\n *\r\n * Triggered when a toolbar is opened.\r\n */\r\nL.Draw.Event.TOOLBAROPENED = 'draw:toolbaropened';\r\n\r\n/**\r\n * @event draw:toolbarclosed: String\r\n *\r\n * Triggered when a toolbar is closed.\r\n */\r\nL.Draw.Event.TOOLBARCLOSED = 'draw:toolbarclosed';\r\n\r\n/**\r\n * @event draw:markercontext: String\r\n *\r\n * Triggered when a marker is right clicked.\r\n */\r\nL.Draw.Event.MARKERCONTEXT = 'draw:markercontext';","L.Draw = L.Draw || {};\r\n\r\n/**\r\n * @class L.Draw.Feature\r\n * @aka Draw.Feature\r\n */\r\nL.Draw.Feature = L.Handler.extend({\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tthis._map = map;\r\n\t\tthis._container = map._container;\r\n\t\tthis._overlayPane = map._panes.overlayPane;\r\n\t\tthis._popupPane = map._panes.popupPane;\r\n\r\n\t\t// Merge default shapeOptions options with custom shapeOptions\r\n\t\tif (options && options.shapeOptions) {\r\n\t\t\toptions.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);\r\n\t\t}\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tvar version = L.version.split('.');\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.Draw.Feature.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.Draw.Feature.include(L.Mixin.Events);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enables this handler\r\n\tenable: function () {\r\n\t\tif (this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\r\n\t\tthis.fire('enabled', {handler: this.type});\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DRAWSTART, {layerType: this.type});\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DRAWSTOP, {layerType: this.type});\r\n\r\n\t\tthis.fire('disabled', {handler: this.type});\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add's event listeners to this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Removes event listeners from this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tL.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method setOptions(object): void\r\n\t// Sets new options to this handler\r\n\tsetOptions: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t_fireCreatedEvent: function (layer) {\r\n\t\tthis._map.fire(L.Draw.Event.CREATED, {layer: layer, layerType: this.type});\r\n\t},\r\n\r\n\t// Cancel drawing when the escape key is pressed\r\n\t_cancelDrawing: function (e) {\r\n\t\tif (e.keyCode === 27) {\r\n\t\t\tthis._map.fire('draw:canceled', {layerType: this.type});\r\n\t\t\tthis.disable();\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Polyline\r\n * @aka Draw.Polyline\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.Polyline = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'polyline'\r\n\t},\r\n\r\n\tPoly: L.Polyline,\r\n\r\n\toptions: {\r\n\t\tallowIntersection: true,\r\n\t\trepeatMode: false,\r\n\t\tdrawError: {\r\n\t\t\tcolor: '#b00b00',\r\n\t\t\ttimeout: 2500\r\n\t\t},\r\n\t\ticon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\r\n\t\t}),\r\n\t\ttouchIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\r\n\t\t}),\r\n\t\tguidelineDistance: 20,\r\n\t\tmaxGuideLineLength: 4000,\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: false,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\r\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\r\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\r\n\t\tshowLength: true, // Whether to display distance in the tooltip\r\n\t\tzIndexOffset: 2000, // This should be > than the highest z-index any map layers\r\n\t\tfactor: 1, // To change distance calculation\r\n\t\tmaxPoints: 0 // Once this number of points are placed, finish shape\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.icon = this.options.touchIcon;\r\n\t\t}\r\n\r\n\t\t// Need to set this here to ensure the correct message is used.\r\n\t\tthis.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;\r\n\r\n\t\t// Merge default drawError options with custom options\r\n\t\tif (options && options.drawError) {\r\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\r\n\t\t}\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Polyline.TYPE;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\t\tif (this._map) {\r\n\t\t\tthis._markers = [];\r\n\r\n\t\t\tthis._markerGroup = new L.LayerGroup();\r\n\t\t\tthis._map.addLayer(this._markerGroup);\r\n\r\n\t\t\tthis._poly = new L.Polyline([], this.options.shapeOptions);\r\n\r\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\r\n\r\n\t\t\t// Make a transparent marker that will used to catch click events. These click\r\n\t\t\t// events will create the vertices. We need to do this so we can ensure that\r\n\t\t\t// we can create vertices over other map layers (markers, vector layers). We\r\n\t\t\t// also do not want to trigger any click handlers of objects we are clicking on\r\n\t\t\t// while drawing.\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40]\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker\r\n\t\t\t\t.on('mouseout', this._onMouseOut, this)\r\n\t\t\t\t.on('mousemove', this._onMouseMove, this) // Necessary to prevent 0.8 stutter\r\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\r\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.8 compatibility\r\n\t\t\t\t.addTo(this._map);\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.on('mouseup', this._onMouseUp, this) // Necessary for 0.7 compatibility\r\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.on('zoomlevelschange', this._onZoomEnd, this)\r\n\t\t\t\t.on('touchstart', this._onTouch, this)\r\n\t\t\t\t.on('zoomend', this._onZoomEnd, this);\r\n\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tthis._clearHideErrorTimeout();\r\n\r\n\t\tthis._cleanUpShape();\r\n\r\n\t\t// remove markers from map\r\n\t\tthis._map.removeLayer(this._markerGroup);\r\n\t\tdelete this._markerGroup;\r\n\t\tdelete this._markers;\r\n\r\n\t\tthis._map.removeLayer(this._poly);\r\n\t\tdelete this._poly;\r\n\r\n\t\tthis._mouseMarker\r\n\t\t\t.off('mousedown', this._onMouseDown, this)\r\n\t\t\t.off('mouseout', this._onMouseOut, this)\r\n\t\t\t.off('mouseup', this._onMouseUp, this)\r\n\t\t\t.off('mousemove', this._onMouseMove, this);\r\n\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\tdelete this._mouseMarker;\r\n\r\n\t\t// clean up DOM\r\n\t\tthis._clearGuides();\r\n\r\n\t\tthis._map\r\n\t\t\t.off('mouseup', this._onMouseUp, this)\r\n\t\t\t.off('mousemove', this._onMouseMove, this)\r\n\t\t\t.off('zoomlevelschange', this._onZoomEnd, this)\r\n\t\t\t.off('zoomend', this._onZoomEnd, this)\r\n\t\t\t.off('touchstart', this._onTouch, this)\r\n\t\t\t.off('click', this._onTouch, this);\r\n\t},\r\n\r\n\t// @method deleteLastVertex(): void\r\n\t// Remove the last vertex from the polyline, removes polyline from map if only one point exists.\r\n\tdeleteLastVertex: function () {\r\n\t\tif (this._markers.length <= 1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar lastMarker = this._markers.pop(),\r\n\t\t\tpoly = this._poly,\r\n\t\t\t// Replaces .spliceLatLngs()\r\n\t\t\tlatlngs = poly.getLatLngs(),\r\n\t\t\tlatlng = latlngs.splice(-1, 1)[0];\r\n\t\tthis._poly.setLatLngs(latlngs);\r\n\r\n\t\tthis._markerGroup.removeLayer(lastMarker);\r\n\r\n\t\tif (poly.getLatLngs().length < 2) {\r\n\t\t\tthis._map.removeLayer(poly);\r\n\t\t}\r\n\r\n\t\tthis._vertexChanged(latlng, false);\r\n\t},\r\n\r\n\t// @method addVertex(): void\r\n\t// Add a vertex to the end of the polyline\r\n\taddVertex: function (latlng) {\r\n\t\tvar markersLength = this._markers.length;\r\n\t\t// markersLength must be greater than or equal to 2 before intersections can occur\r\n\t\tif (markersLength >= 2 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {\r\n\t\t\tthis._showErrorTooltip();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse if (this._errorShown) {\r\n\t\t\tthis._hideErrorTooltip();\r\n\t\t}\r\n\r\n\t\tthis._markers.push(this._createMarker(latlng));\r\n\r\n\t\tthis._poly.addLatLng(latlng);\r\n\r\n\t\tif (this._poly.getLatLngs().length === 2) {\r\n\t\t\tthis._map.addLayer(this._poly);\r\n\t\t}\r\n\r\n\t\tthis._vertexChanged(latlng, true);\r\n\t},\r\n\r\n\t// @method completeShape(): void\r\n\t// Closes the polyline between the first and last points\r\n\tcompleteShape: function () {\r\n\t\tif (this._markers.length <= 1 || !this._shapeIsValid()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._fireCreatedEvent();\r\n\t\tthis.disable();\r\n\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_finishShape: function () {\r\n\t\tvar latlngs = this._poly._defaultShape ? this._poly._defaultShape() : this._poly.getLatLngs();\r\n\t\tvar intersects = this._poly.newLatLngIntersects(latlngs[latlngs.length - 1]);\r\n\r\n\t\tif ((!this.options.allowIntersection && intersects) || !this._shapeIsValid()) {\r\n\t\t\tthis._showErrorTooltip();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._fireCreatedEvent();\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t// Called to verify the shape is valid when the user tries to finish it\r\n\t// Return false if the shape is not valid\r\n\t_shapeIsValid: function () {\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_onZoomEnd: function () {\r\n\t\tif (this._markers !== null) {\r\n\t\t\tthis._updateGuide();\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar newPos = this._map.mouseEventToLayerPoint(e.originalEvent);\r\n\t\tvar latlng = this._map.layerPointToLatLng(newPos);\r\n\r\n\t\t// Save latlng\r\n\t\t// should this be moved to _updateGuide() ?\r\n\t\tthis._currentLatLng = latlng;\r\n\r\n\t\tthis._updateTooltip(latlng);\r\n\r\n\t\t// Update the guide line\r\n\t\tthis._updateGuide(newPos);\r\n\r\n\t\t// Update the mouse marker position\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tL.DomEvent.preventDefault(e.originalEvent);\r\n\t},\r\n\r\n\t_vertexChanged: function (latlng, added) {\r\n\t\tthis._map.fire(L.Draw.Event.DRAWVERTEX, {layers: this._markerGroup});\r\n\t\tthis._updateFinishHandler();\r\n\r\n\t\tthis._updateRunningMeasure(latlng, added);\r\n\r\n\t\tthis._clearGuides();\r\n\r\n\t\tthis._updateTooltip();\r\n\t},\r\n\r\n\t_onMouseDown: function (e) {\r\n\t\tif (!this._clickHandled && !this._touchHandled && !this._disableMarkers) {\r\n\t\t\tthis._onMouseMove(e);\r\n\t\t\tthis._clickHandled = true;\r\n\t\t\tthis._disableNewMarkers();\r\n\t\t\tvar originalEvent = e.originalEvent;\r\n\t\t\tvar clientX = originalEvent.clientX;\r\n\t\t\tvar clientY = originalEvent.clientY;\r\n\t\t\tthis._startPoint.call(this, clientX, clientY);\r\n\t\t}\r\n\t},\r\n\r\n\t_startPoint: function (clientX, clientY) {\r\n\t\tthis._mouseDownOrigin = L.point(clientX, clientY);\r\n\t},\r\n\r\n\t_onMouseUp: function (e) {\r\n\t\tvar originalEvent = e.originalEvent;\r\n\t\tvar clientX = originalEvent.clientX;\r\n\t\tvar clientY = originalEvent.clientY;\r\n\t\tthis._endPoint.call(this, clientX, clientY, e);\r\n\t\tthis._clickHandled = null;\r\n\t},\r\n\r\n\t_endPoint: function (clientX, clientY, e) {\r\n\t\tif (this._mouseDownOrigin) {\r\n\t\t\tvar dragCheckDistance = L.point(clientX, clientY)\r\n\t\t\t\t.distanceTo(this._mouseDownOrigin);\r\n\t\t\tvar lastPtDistance = this._calculateFinishDistance(e.latlng);\r\n\t\t\tif (this.options.maxPoints > 1 && this.options.maxPoints == this._markers.length + 1) {\r\n\t\t\t\tthis.addVertex(e.latlng);\r\n\t\t\t\tthis._finishShape();\r\n\t\t\t} else if (lastPtDistance < 10 && L.Browser.touch) {\r\n\t\t\t\tthis._finishShape();\r\n\t\t\t} else if (Math.abs(dragCheckDistance) < 9 * (window.devicePixelRatio || 1)) {\r\n\t\t\t\tthis.addVertex(e.latlng);\r\n\t\t\t}\r\n\t\t\tthis._enableNewMarkers(); // after a short pause, enable new markers\r\n\t\t}\r\n\t\tthis._mouseDownOrigin = null;\r\n\t},\r\n\r\n\t// ontouch prevented by clickHandled flag because some browsers fire both click/touch events,\r\n\t// causing unwanted behavior\r\n\t_onTouch: function (e) {\r\n\t\tvar originalEvent = e.originalEvent;\r\n\t\tvar clientX;\r\n\t\tvar clientY;\r\n\t\tif (originalEvent.touches && originalEvent.touches[0] && !this._clickHandled && !this._touchHandled && !this._disableMarkers) {\r\n\t\t\tclientX = originalEvent.touches[0].clientX;\r\n\t\t\tclientY = originalEvent.touches[0].clientY;\r\n\t\t\tthis._disableNewMarkers();\r\n\t\t\tthis._touchHandled = true;\r\n\t\t\tthis._startPoint.call(this, clientX, clientY);\r\n\t\t\tthis._endPoint.call(this, clientX, clientY, e);\r\n\t\t\tthis._touchHandled = null;\r\n\t\t}\r\n\t\tthis._clickHandled = null;\r\n\t},\r\n\r\n\t_onMouseOut: function () {\r\n\t\tif (this._tooltip) {\r\n\t\t\tthis._tooltip._onMouseOut.call(this._tooltip);\r\n\t\t}\r\n\t},\r\n\r\n\t// calculate if we are currently within close enough distance\r\n\t// of the closing point (first point for shapes, last point for lines)\r\n\t// this is semi-ugly code but the only reliable way i found to get the job done\r\n\t// note: calculating point.distanceTo between mouseDownOrigin and last marker did NOT work\r\n\t_calculateFinishDistance: function (potentialLatLng) {\r\n\t\tvar lastPtDistance;\r\n\t\tif (this._markers.length > 0) {\r\n\t\t\tvar finishMarker;\r\n\t\t\tif (this.type === L.Draw.Polyline.TYPE) {\r\n\t\t\t\tfinishMarker = this._markers[this._markers.length - 1];\r\n\t\t\t} else if (this.type === L.Draw.Polygon.TYPE) {\r\n\t\t\t\tfinishMarker = this._markers[0];\r\n\t\t\t} else {\r\n\t\t\t\treturn Infinity;\r\n\t\t\t}\r\n\t\t\tvar lastMarkerPoint = this._map.latLngToContainerPoint(finishMarker.getLatLng()),\r\n\t\t\t\tpotentialMarker = new L.Marker(potentialLatLng, {\r\n\t\t\t\t\ticon: this.options.icon,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset * 2\r\n\t\t\t\t});\r\n\t\t\tvar potentialMarkerPint = this._map.latLngToContainerPoint(potentialMarker.getLatLng());\r\n\t\t\tlastPtDistance = lastMarkerPoint.distanceTo(potentialMarkerPint);\r\n\t\t} else {\r\n\t\t\tlastPtDistance = Infinity;\r\n\t\t}\r\n\t\treturn lastPtDistance;\r\n\t},\r\n\r\n\t_updateFinishHandler: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\t\t// The last marker should have a click handler to close the polyline\r\n\t\tif (markerCount > 1) {\r\n\t\t\tthis._markers[markerCount - 1].on('click', this._finishShape, this);\r\n\t\t}\r\n\r\n\t\t// Remove the old marker click handler (as only the last point should close the polyline)\r\n\t\tif (markerCount > 2) {\r\n\t\t\tthis._markers[markerCount - 2].off('click', this._finishShape, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\tvar marker = new L.Marker(latlng, {\r\n\t\t\ticon: this.options.icon,\r\n\t\t\tzIndexOffset: this.options.zIndexOffset * 2\r\n\t\t});\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\r\n\t\treturn marker;\r\n\t},\r\n\r\n\t_updateGuide: function (newPos) {\r\n\t\tvar markerCount = this._markers ? this._markers.length : 0;\r\n\r\n\t\tif (markerCount > 0) {\r\n\t\t\tnewPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);\r\n\r\n\t\t\t// draw the guide line\r\n\t\t\tthis._clearGuides();\r\n\t\t\tthis._drawGuide(\r\n\t\t\t\tthis._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()),\r\n\t\t\t\tnewPos\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\t_updateTooltip: function (latLng) {\r\n\t\tvar text = this._getTooltipText();\r\n\r\n\t\tif (latLng) {\r\n\t\t\tthis._tooltip.updatePosition(latLng);\r\n\t\t}\r\n\r\n\t\tif (!this._errorShown) {\r\n\t\t\tthis._tooltip.updateContent(text);\r\n\t\t}\r\n\t},\r\n\r\n\t_drawGuide: function (pointA, pointB) {\r\n\t\tvar length = Math.floor(Math.sqrt(Math.pow((pointB.x - pointA.x), 2) + Math.pow((pointB.y - pointA.y), 2))),\r\n\t\t\tguidelineDistance = this.options.guidelineDistance,\r\n\t\t\tmaxGuideLineLength = this.options.maxGuideLineLength,\r\n\t\t\t// Only draw a guideline with a max length\r\n\t\t\ti = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,\r\n\t\t\tfraction,\r\n\t\t\tdashPoint,\r\n\t\t\tdash;\r\n\r\n\t\t//create the guides container if we haven't yet\r\n\t\tif (!this._guidesContainer) {\r\n\t\t\tthis._guidesContainer = L.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);\r\n\t\t}\r\n\r\n\t\t//draw a dash every GuildeLineDistance\r\n\t\tfor (; i < length; i += this.options.guidelineDistance) {\r\n\t\t\t//work out fraction along line we are\r\n\t\t\tfraction = i / length;\r\n\r\n\t\t\t//calculate new x,y point\r\n\t\t\tdashPoint = {\r\n\t\t\t\tx: Math.floor((pointA.x * (1 - fraction)) + (fraction * pointB.x)),\r\n\t\t\t\ty: Math.floor((pointA.y * (1 - fraction)) + (fraction * pointB.y))\r\n\t\t\t};\r\n\r\n\t\t\t//add guide dash to guide container\r\n\t\t\tdash = L.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);\r\n\t\t\tdash.style.backgroundColor =\r\n\t\t\t\t!this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;\r\n\r\n\t\t\tL.DomUtil.setPosition(dash, dashPoint);\r\n\t\t}\r\n\t},\r\n\r\n\t_updateGuideColor: function (color) {\r\n\t\tif (this._guidesContainer) {\r\n\t\t\tfor (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {\r\n\t\t\t\tthis._guidesContainer.childNodes[i].style.backgroundColor = color;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// removes all child elements (guide dashes) from the guides container\r\n\t_clearGuides: function () {\r\n\t\tif (this._guidesContainer) {\r\n\t\t\twhile (this._guidesContainer.firstChild) {\r\n\t\t\t\tthis._guidesContainer.removeChild(this._guidesContainer.firstChild);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar showLength = this.options.showLength,\r\n\t\t\tlabelText, distanceStr;\r\n\t\tif (this._markers.length === 0) {\r\n\t\t\tlabelText = {\r\n\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.start\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tdistanceStr = showLength ? this._getMeasurementString() : '';\r\n\r\n\t\t\tif (this._markers.length === 1) {\r\n\t\t\t\tlabelText = {\r\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.cont,\r\n\t\t\t\t\tsubtext: distanceStr\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tlabelText = {\r\n\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.tooltip.end,\r\n\t\t\t\t\tsubtext: distanceStr\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn labelText;\r\n\t},\r\n\r\n\t_updateRunningMeasure: function (latlng, added) {\r\n\t\tvar markersLength = this._markers.length,\r\n\t\t\tpreviousMarkerIndex, distance;\r\n\r\n\t\tif (this._markers.length === 1) {\r\n\t\t\tthis._measurementRunningTotal = 0;\r\n\t\t} else {\r\n\t\t\tpreviousMarkerIndex = markersLength - (added ? 2 : 1);\r\n\r\n\t\t\t// Calculate the distance based on the version\r\n\t\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\t\tdistance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\r\n\t\t\t} else {\r\n\t\t\t\tdistance = this._map.distance(latlng, this._markers[previousMarkerIndex].getLatLng()) * (this.options.factor || 1);\r\n\t\t\t}\r\n\r\n\t\t\tthis._measurementRunningTotal += distance * (added ? 1 : -1);\r\n\t\t}\r\n\t},\r\n\r\n\t_getMeasurementString: function () {\r\n\t\tvar currentLatLng = this._currentLatLng,\r\n\t\t\tpreviousLatLng = this._markers[this._markers.length - 1].getLatLng(),\r\n\t\t\tdistance;\r\n\r\n\t\t// Calculate the distance from the last fixed point to the mouse position based on the version\r\n\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\tdistance = previousLatLng && currentLatLng && currentLatLng.distanceTo ? this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\r\n\t\t} else {\r\n\t\t\tdistance = previousLatLng && currentLatLng ? this._measurementRunningTotal + this._map.distance(currentLatLng, previousLatLng) * (this.options.factor || 1) : this._measurementRunningTotal || 0;\r\n\t\t}\r\n\r\n\t\treturn L.GeometryUtil.readableDistance(distance, this.options.metric, this.options.feet, this.options.nautic, this.options.precision);\r\n\t},\r\n\r\n\t_showErrorTooltip: function () {\r\n\t\tthis._errorShown = true;\r\n\r\n\t\t// Update tooltip\r\n\t\tthis._tooltip\r\n\t\t\t.showAsError()\r\n\t\t\t.updateContent({text: this.options.drawError.message});\r\n\r\n\t\t// Update shape\r\n\t\tthis._updateGuideColor(this.options.drawError.color);\r\n\t\tthis._poly.setStyle({color: this.options.drawError.color});\r\n\r\n\t\t// Hide the error after 2 seconds\r\n\t\tthis._clearHideErrorTimeout();\r\n\t\tthis._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);\r\n\t},\r\n\r\n\t_hideErrorTooltip: function () {\r\n\t\tthis._errorShown = false;\r\n\r\n\t\tthis._clearHideErrorTimeout();\r\n\r\n\t\t// Revert tooltip\r\n\t\tthis._tooltip\r\n\t\t\t.removeError()\r\n\t\t\t.updateContent(this._getTooltipText());\r\n\r\n\t\t// Revert shape\r\n\t\tthis._updateGuideColor(this.options.shapeOptions.color);\r\n\t\tthis._poly.setStyle({color: this.options.shapeOptions.color});\r\n\t},\r\n\r\n\t_clearHideErrorTimeout: function () {\r\n\t\tif (this._hideErrorTimeout) {\r\n\t\t\tclearTimeout(this._hideErrorTimeout);\r\n\t\t\tthis._hideErrorTimeout = null;\r\n\t\t}\r\n\t},\r\n\r\n\t// disable new markers temporarily;\r\n\t// this is to prevent duplicated touch/click events in some browsers\r\n\t_disableNewMarkers: function () {\r\n\t\tthis._disableMarkers = true;\r\n\t},\r\n\r\n\t// see _disableNewMarkers\r\n\t_enableNewMarkers: function () {\r\n\t\tsetTimeout(function () {\r\n\t\t\tthis._disableMarkers = false;\r\n\t\t}.bind(this), 50);\r\n\t},\r\n\r\n\t_cleanUpShape: function () {\r\n\t\tif (this._markers.length > 1) {\r\n\t\t\tthis._markers[this._markers.length - 1].off('click', this._finishShape, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Polygon\r\n * @aka Draw.Polygon\r\n * @inherits L.Draw.Polyline\r\n */\r\nL.Draw.Polygon = L.Draw.Polyline.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'polygon'\r\n\t},\r\n\r\n\tPoly: L.Polygon,\r\n\r\n\toptions: {\r\n\t\tshowArea: false,\r\n\t\tshowLength: false,\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\t// Whether to use the metric measurement system (truthy) or not (falsy).\r\n\t\t// Also defines the units to use for the metric system as an array of\r\n\t\t// strings (e.g. `['ha', 'm']`).\r\n\t\tmetric: true,\r\n\t\tfeet: true, // When not metric, to use feet instead of yards for display.\r\n\t\tnautic: false, // When not metric, not feet use nautic mile for display\r\n\t\t// Defines the precision for each type of unit (e.g. {km: 2, ft: 0}\r\n\t\tprecision: {}\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Draw.Polyline.prototype.initialize.call(this, map, options);\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Polygon.TYPE;\r\n\t},\r\n\r\n\t_updateFinishHandler: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\r\n\t\t// The first marker should have a click handler to close the polygon\r\n\t\tif (markerCount === 1) {\r\n\t\t\tthis._markers[0].on('click', this._finishShape, this);\r\n\t\t}\r\n\r\n\t\t// Add and update the double click handler\r\n\t\tif (markerCount > 2) {\r\n\t\t\tthis._markers[markerCount - 1].on('dblclick', this._finishShape, this);\r\n\t\t\t// Only need to remove handler if has been added before\r\n\t\t\tif (markerCount > 3) {\r\n\t\t\t\tthis._markers[markerCount - 2].off('dblclick', this._finishShape, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar text, subtext;\r\n\r\n\t\tif (this._markers.length === 0) {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.start;\r\n\t\t} else if (this._markers.length < 3) {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.cont;\r\n\t\t\tsubtext = this._getMeasurementString();\r\n\t\t} else {\r\n\t\t\ttext = L.drawLocal.draw.handlers.polygon.tooltip.end;\r\n\t\t\tsubtext = this._getMeasurementString();\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttext: text,\r\n\t\t\tsubtext: subtext\r\n\t\t};\r\n\t},\r\n\r\n\t_getMeasurementString: function () {\r\n\t\tvar area = this._area,\r\n\t\t\tmeasurementString = '';\r\n\r\n\r\n\t\tif (!area && !this.options.showLength) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (this.options.showLength) {\r\n\t\t\tmeasurementString = L.Draw.Polyline.prototype._getMeasurementString.call(this);\r\n\t\t}\r\n\r\n\t\tif (area) {\r\n\t\t\tmeasurementString += '<br>' + L.GeometryUtil.readableArea(area, this.options.metric, this.options.precision);\r\n\t\t}\r\n\r\n\t\treturn measurementString;\r\n\t},\r\n\r\n\t_shapeIsValid: function () {\r\n\t\treturn this._markers.length >= 3;\r\n\t},\r\n\r\n\t_vertexChanged: function (latlng, added) {\r\n\t\tvar latLngs;\r\n\r\n\t\t// Check to see if we should show the area\r\n\t\tif (!this.options.allowIntersection && this.options.showArea) {\r\n\t\t\tlatLngs = this._poly.getLatLngs();\r\n\r\n\t\t\tthis._area = L.GeometryUtil.geodesicArea(latLngs);\r\n\t\t}\r\n\r\n\t\tL.Draw.Polyline.prototype._vertexChanged.call(this, latlng, added);\r\n\t},\r\n\r\n\t_cleanUpShape: function () {\r\n\t\tvar markerCount = this._markers.length;\r\n\r\n\t\tif (markerCount > 0) {\r\n\t\t\tthis._markers[0].off('click', this._finishShape, this);\r\n\r\n\t\t\tif (markerCount > 2) {\r\n\t\t\t\tthis._markers[markerCount - 1].off('dblclick', this._finishShape, this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n","L.SimpleShape = {};\r\n/**\r\n * @class L.Draw.SimpleShape\r\n * @aka Draw.SimpleShape\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.SimpleShape = L.Draw.Feature.extend({\r\n\toptions: {\r\n\t\trepeatMode: false\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tthis._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\t\tif (this._map) {\r\n\t\t\tthis._mapDraggable = this._map.dragging.enabled();\r\n\r\n\t\t\tif (this._mapDraggable) {\r\n\t\t\t\tthis._map.dragging.disable();\r\n\t\t\t}\r\n\r\n\t\t\t//TODO refactor: move cursor to styles\r\n\t\t\tthis._container.style.cursor = 'crosshair';\r\n\r\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.on('mousedown', this._onMouseDown, this)\r\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.on('touchstart', this._onMouseDown, this)\r\n\t\t\t\t.on('touchmove', this._onMouseMove, this);\r\n\r\n\t\t\t// we should prevent default, otherwise default behavior (scrolling) will fire,\r\n\t\t\t// and that will cause document.touchend to fire and will stop the drawing\r\n\t\t\t// (circle, rectangle) in touch mode.\r\n\t\t\t// (update): we have to send passive now to prevent scroll, because by default it is {passive: true} now, which means,\r\n\t\t\t// handler can't event.preventDefault\r\n\t\t\t// check the news https://developers.google.com/web/updates/2016/06/passive-event-listeners\r\n\t\t\tdocument.addEventListener('touchstart', L.DomEvent.preventDefault, {passive: false});\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\t\tif (this._map) {\r\n\t\t\tif (this._mapDraggable) {\r\n\t\t\t\tthis._map.dragging.enable();\r\n\t\t\t}\r\n\r\n\t\t\t//TODO refactor: move cursor to styles\r\n\t\t\tthis._container.style.cursor = '';\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.off('mousedown', this._onMouseDown, this)\r\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.off('touchstart', this._onMouseDown, this)\r\n\t\t\t\t.off('touchmove', this._onMouseMove, this);\r\n\r\n\t\t\tL.DomEvent.off(document, 'mouseup', this._onMouseUp, this);\r\n\t\t\tL.DomEvent.off(document, 'touchend', this._onMouseUp, this);\r\n\r\n\t\t\tdocument.removeEventListener('touchstart', L.DomEvent.preventDefault);\r\n\r\n\t\t\t// If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return\r\n\t\t\tif (this._shape) {\r\n\t\t\t\tthis._map.removeLayer(this._shape);\r\n\t\t\t\tdelete this._shape;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._isDrawing = false;\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\treturn {\r\n\t\t\ttext: this._endLabelText\r\n\t\t};\r\n\t},\r\n\r\n\t_onMouseDown: function (e) {\r\n\t\tthis._isDrawing = true;\r\n\t\tthis._startLatLng = e.latlng;\r\n\r\n\t\tL.DomEvent\r\n\t\t\t.on(document, 'mouseup', this._onMouseUp, this)\r\n\t\t\t.on(document, 'touchend', this._onMouseUp, this)\r\n\t\t\t.preventDefault(e.originalEvent);\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tif (this._isDrawing) {\r\n\t\t\tthis._tooltip.updateContent(this._getTooltipText());\r\n\t\t\tthis._drawShape(latlng);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseUp: function () {\r\n\t\tif (this._shape) {\r\n\t\t\tthis._fireCreatedEvent();\r\n\t\t}\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Rectangle\r\n * @aka Draw.Rectangle\r\n * @inherits L.Draw.SimpleShape\r\n */\r\nL.Draw.Rectangle = L.Draw.SimpleShape.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'rectangle'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\tshowArea: true, //Whether to show the area in the tooltip\r\n\t\tmetric: true // Whether to use the metric measurement system or imperial\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Rectangle.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;\r\n\r\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._isCurrentlyTwoClickDrawing = false;\r\n\t\tL.Draw.SimpleShape.prototype.disable.call(this);\r\n\t},\r\n\r\n\t_onMouseUp: function (e) {\r\n\t\tif (!this._shape && !this._isCurrentlyTwoClickDrawing) {\r\n\t\t\tthis._isCurrentlyTwoClickDrawing = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Make sure closing click is on map\r\n\t\tif (this._isCurrentlyTwoClickDrawing && !_hasAncestor(e.target, 'leaflet-pane')) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tL.Draw.SimpleShape.prototype._onMouseUp.call(this);\r\n\t},\r\n\r\n\t_drawShape: function (latlng) {\r\n\t\tif (!this._shape) {\r\n\t\t\tthis._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);\r\n\t\t\tthis._map.addLayer(this._shape);\r\n\t\t} else {\r\n\t\t\tthis._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));\r\n\t\t}\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);\r\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\tvar tooltipText = L.Draw.SimpleShape.prototype._getTooltipText.call(this),\r\n\t\t\tshape = this._shape,\r\n\t\t\tshowArea = this.options.showArea,\r\n\t\t\tlatLngs, area, subtext;\r\n\r\n\t\tif (shape) {\r\n\t\t\tlatLngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs();\r\n\t\t\tarea = L.GeometryUtil.geodesicArea(latLngs);\r\n\t\t\tsubtext = showArea ? L.GeometryUtil.readableArea(area, this.options.metric) : '';\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttext: tooltipText.text,\r\n\t\t\tsubtext: subtext\r\n\t\t};\r\n\t}\r\n});\r\n\r\nfunction _hasAncestor(el, cls) {\r\n\twhile ((el = el.parentElement) && !el.classList.contains(cls)) {\r\n\t\t;\r\n\t}\r\n\treturn el;\r\n}\r\n","/**\r\n * @class L.Draw.Marker\r\n * @aka Draw.Marker\r\n * @inherits L.Draw.Feature\r\n */\r\nL.Draw.Marker = L.Draw.Feature.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'marker'\r\n\t},\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\trepeatMode: false,\r\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Marker.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.marker.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tL.Draw.Feature.prototype.addHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._tooltip.updateContent({text: this._initialLabelText});\r\n\r\n\t\t\t// Same mouseMarker as in Draw.Polyline\r\n\t\t\tif (!this._mouseMarker) {\r\n\t\t\t\tthis._mouseMarker = L.marker(this._map.getCenter(), {\r\n\t\t\t\t\ticon: L.divIcon({\r\n\t\t\t\t\t\tclassName: 'leaflet-mouse-marker',\r\n\t\t\t\t\t\ticonAnchor: [20, 20],\r\n\t\t\t\t\t\ticonSize: [40, 40]\r\n\t\t\t\t\t}),\r\n\t\t\t\t\topacity: 0,\r\n\t\t\t\t\tzIndexOffset: this.options.zIndexOffset\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker\r\n\t\t\t\t.on('click', this._onClick, this)\r\n\t\t\t\t.addTo(this._map);\r\n\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click', this._onTouch, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tL.Draw.Feature.prototype.removeHooks.call(this);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map\r\n\t\t\t\t.off('click', this._onClick, this)\r\n\t\t\t\t.off('click', this._onTouch, this);\r\n\t\t\tif (this._marker) {\r\n\t\t\t\tthis._marker.off('click', this._onClick, this);\r\n\t\t\t\tthis._map\r\n\t\t\t\t\t.removeLayer(this._marker);\r\n\t\t\t\tdelete this._marker;\r\n\t\t\t}\r\n\r\n\t\t\tthis._mouseMarker.off('click', this._onClick, this);\r\n\t\t\tthis._map.removeLayer(this._mouseMarker);\r\n\t\t\tdelete this._mouseMarker;\r\n\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tthis._mouseMarker.setLatLng(latlng);\r\n\r\n\t\tif (!this._marker) {\r\n\t\t\tthis._marker = this._createMarker(latlng);\r\n\t\t\t// Bind to both marker and map to make sure we get the click event.\r\n\t\t\tthis._marker.on('click', this._onClick, this);\r\n\t\t\tthis._map\r\n\t\t\t\t.on('click', this._onClick, this)\r\n\t\t\t\t.addLayer(this._marker);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlatlng = this._mouseMarker.getLatLng();\r\n\t\t\tthis._marker.setLatLng(latlng);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\treturn new L.Marker(latlng, {\r\n\t\t\ticon: this.options.icon,\r\n\t\t\tzIndexOffset: this.options.zIndexOffset\r\n\t\t});\r\n\t},\r\n\r\n\t_onClick: function () {\r\n\t\tthis._fireCreatedEvent();\r\n\r\n\t\tthis.disable();\r\n\t\tif (this.options.repeatMode) {\r\n\t\t\tthis.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onTouch: function (e) {\r\n\t\t// called on click & tap, only really does any thing on tap\r\n\t\tthis._onMouseMove(e); // creates & places marker\r\n\t\tthis._onClick(); // permanently places marker & ends interaction\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar marker = new L.Marker.Touch(this._marker.getLatLng(), {icon: this.options.icon});\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.CircleMarker\r\n * @aka Draw.CircleMarker\r\n * @inherits L.Draw.Marker\r\n */\r\nL.Draw.CircleMarker = L.Draw.Marker.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'circlemarker'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#3388ff',\r\n\t\tweight: 4,\r\n\t\topacity: 0.5,\r\n\t\tfill: true,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\t\tclickable: true,\r\n\t\tzIndexOffset: 2000 // This should be > than the highest z-index any markers\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.CircleMarker.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circlemarker.tooltip.start;\r\n\r\n\t\tL.Draw.Feature.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar circleMarker = new L.CircleMarker(this._marker.getLatLng(), this.options);\r\n\t\tL.Draw.Feature.prototype._fireCreatedEvent.call(this, circleMarker);\r\n\t},\r\n\r\n\t_createMarker: function (latlng) {\r\n\t\treturn new L.CircleMarker(latlng, this.options);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Circle\r\n * @aka Draw.Circle\r\n * @inherits L.Draw.SimpleShape\r\n */\r\nL.Draw.Circle = L.Draw.SimpleShape.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'circle'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tshapeOptions: {\r\n\t\t\tstroke: true,\r\n\t\t\tcolor: '#3388ff',\r\n\t\t\tweight: 4,\r\n\t\t\topacity: 0.5,\r\n\t\t\tfill: true,\r\n\t\t\tfillColor: null, //same as color by default\r\n\t\t\tfillOpacity: 0.2,\r\n\t\t\tclickable: true\r\n\t\t},\r\n\t\tshowRadius: true,\r\n\t\tmetric: true, // Whether to use the metric measurement system or imperial\r\n\t\tfeet: true, // When not metric, use feet instead of yards for display\r\n\t\tnautic: false // When not metric, not feet use nautic mile for display\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.Draw.Circle.TYPE;\r\n\r\n\t\tthis._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;\r\n\r\n\t\tL.Draw.SimpleShape.prototype.initialize.call(this, map, options);\r\n\t},\r\n\r\n\t_drawShape: function (latlng) {\r\n\t\t// Calculate the distance based on the version\r\n\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\tvar distance = this._startLatLng.distanceTo(latlng);\r\n\t\t} else {\r\n\t\t\tvar distance = this._map.distance(this._startLatLng, latlng);\r\n\t\t}\r\n\r\n\t\tif (!this._shape) {\r\n\t\t\tthis._shape = new L.Circle(this._startLatLng, distance, this.options.shapeOptions);\r\n\t\t\tthis._map.addLayer(this._shape);\r\n\t\t} else {\r\n\t\t\tthis._shape.setRadius(distance);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireCreatedEvent: function () {\r\n\t\tvar circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);\r\n\t\tL.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tvar latlng = e.latlng,\r\n\t\t\tshowRadius = this.options.showRadius,\r\n\t\t\tuseMetric = this.options.metric,\r\n\t\t\tradius;\r\n\r\n\t\tthis._tooltip.updatePosition(latlng);\r\n\t\tif (this._isDrawing) {\r\n\t\t\tthis._drawShape(latlng);\r\n\r\n\t\t\t// Get the new radius (rounded to 1 dp)\r\n\t\t\tradius = this._shape.getRadius().toFixed(1);\r\n\r\n\t\t\tvar subtext = '';\r\n\t\t\tif (showRadius) {\r\n\t\t\t\tsubtext = L.drawLocal.draw.handlers.circle.radius + ': ' +\r\n\t\t\t\t\tL.GeometryUtil.readableDistance(radius, useMetric, this.options.feet, this.options.nautic);\r\n\t\t\t}\r\n\t\t\tthis._tooltip.updateContent({\r\n\t\t\t\ttext: this._endLabelText,\r\n\t\t\t\tsubtext: subtext\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n\r\n/**\r\n * @class L.Edit.Marker\r\n * @aka Edit.Marker\r\n */\r\nL.Edit.Marker = L.Handler.extend({\r\n\t// @method initialize(): void\r\n\tinitialize: function (marker, options) {\r\n\t\tthis._marker = marker;\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar marker = this._marker;\r\n\r\n\t\tmarker.dragging.enable();\r\n\t\tmarker.on('dragend', this._onDragEnd, marker);\r\n\t\tthis._toggleMarkerHighlight();\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tvar marker = this._marker;\r\n\r\n\t\tmarker.dragging.disable();\r\n\t\tmarker.off('dragend', this._onDragEnd, marker);\r\n\t\tthis._toggleMarkerHighlight();\r\n\t},\r\n\r\n\t_onDragEnd: function (e) {\r\n\t\tvar layer = e.target;\r\n\t\tlayer.edited = true;\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: layer});\r\n\t},\r\n\r\n\t_toggleMarkerHighlight: function () {\r\n\t\tvar icon = this._marker._icon;\r\n\r\n\t\t// Don't do anything if this layer is a marker but doesn't have an icon. Markers\r\n\t\t// should usually have icons. If using Leaflet.draw with Leaflet.markercluster there\r\n\t\t// is a chance that a marker doesn't.\r\n\t\tif (!icon) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)\r\n\t\ticon.style.display = 'none';\r\n\r\n\t\tif (L.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {\r\n\t\t\tL.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected');\r\n\t\t\t// Offset as the border will make the icon move.\r\n\t\t\tthis._offsetMarker(icon, -4);\r\n\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(icon, 'leaflet-edit-marker-selected');\r\n\t\t\t// Offset as the border will make the icon move.\r\n\t\t\tthis._offsetMarker(icon, 4);\r\n\t\t}\r\n\r\n\t\ticon.style.display = '';\r\n\t},\r\n\r\n\t_offsetMarker: function (icon, offset) {\r\n\t\tvar iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,\r\n\t\t\ticonMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;\r\n\r\n\t\ticon.style.marginTop = iconMarginTop + 'px';\r\n\t\ticon.style.marginLeft = iconMarginLeft + 'px';\r\n\t}\r\n});\r\n\r\nL.Marker.addInitHook(function () {\r\n\tif (L.Edit.Marker) {\r\n\t\tthis.editing = new L.Edit.Marker(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n\r\n/**\r\n * @class L.Edit.Polyline\r\n * @aka L.Edit.Poly\r\n * @aka Edit.Poly\r\n */\r\nL.Edit.Poly = L.Handler.extend({\r\n\t// @method initialize(): void\r\n\tinitialize: function (poly) {\r\n\r\n\t\tthis.latlngs = [poly._latlngs];\r\n\t\tif (poly._holes) {\r\n\t\t\tthis.latlngs = this.latlngs.concat(poly._holes);\r\n\t\t}\r\n\r\n\t\tthis._poly = poly;\r\n\r\n\t\tthis._poly.on('revert-edited', this._updateLatLngs, this);\r\n\t},\r\n\r\n\t// Compatibility method to normalize Poly* objects\r\n\t// between 0.7.x and 1.0+\r\n\t_defaultShape: function () {\r\n\t\tif (!L.Polyline._flat) {\r\n\t\t\treturn this._poly._latlngs;\r\n\t\t}\r\n\t\treturn L.Polyline._flat(this._poly._latlngs) ? this._poly._latlngs : this._poly._latlngs[0];\r\n\t},\r\n\r\n\t_eachVertexHandler: function (callback) {\r\n\t\tfor (var i = 0; i < this._verticesHandlers.length; i++) {\r\n\t\t\tcallback(this._verticesHandlers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tthis._initHandlers();\r\n\t\tthis._eachVertexHandler(function (handler) {\r\n\t\t\thandler.addHooks();\r\n\t\t});\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tthis._eachVertexHandler(function (handler) {\r\n\t\t\thandler.removeHooks();\r\n\t\t});\r\n\t},\r\n\r\n\t// @method updateMarkers(): void\r\n\t// Fire an update for each vertex handler\r\n\tupdateMarkers: function () {\r\n\t\tthis._eachVertexHandler(function (handler) {\r\n\t\t\thandler.updateMarkers();\r\n\t\t});\r\n\t},\r\n\r\n\t_initHandlers: function () {\r\n\t\tthis._verticesHandlers = [];\r\n\t\tfor (var i = 0; i < this.latlngs.length; i++) {\r\n\t\t\tthis._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly, this.latlngs[i], this._poly.options.poly));\r\n\t\t}\r\n\t},\r\n\r\n\t_updateLatLngs: function (e) {\r\n\t\tthis.latlngs = [e.layer._latlngs];\r\n\t\tif (e.layer._holes) {\r\n\t\t\tthis.latlngs = this.latlngs.concat(e.layer._holes);\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n/**\r\n * @class L.Edit.PolyVerticesEdit\r\n * @aka Edit.PolyVerticesEdit\r\n */\r\nL.Edit.PolyVerticesEdit = L.Handler.extend({\r\n\toptions: {\r\n\t\ticon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon'\r\n\t\t}),\r\n\t\ttouchIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'\r\n\t\t}),\r\n\t\tdrawError: {\r\n\t\t\tcolor: '#b00b00',\r\n\t\t\ttimeout: 1000\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (poly, latlngs, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.icon = this.options.touchIcon;\r\n\t\t}\r\n\t\tthis._poly = poly;\r\n\r\n\t\tif (options && options.drawError) {\r\n\t\t\toptions.drawError = L.Util.extend({}, this.options.drawError, options.drawError);\r\n\t\t}\r\n\r\n\t\tthis._latlngs = latlngs;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\t// Compatibility method to normalize Poly* objects\r\n\t// between 0.7.x and 1.0+\r\n\t_defaultShape: function () {\r\n\t\tif (!L.Polyline._flat) {\r\n\t\t\treturn this._latlngs;\r\n\t\t}\r\n\t\treturn L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler.\r\n\taddHooks: function () {\r\n\t\tvar poly = this._poly;\r\n\t\tvar path = poly._path;\r\n\r\n\t\tif (!(poly instanceof L.Polygon)) {\r\n\t\t\tpoly.options.fill = false;\r\n\t\t\tif (poly.options.editing) {\r\n\t\t\t\tpoly.options.editing.fill = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (path) {\r\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\r\n\t\t\t\tif (poly.options.original.className) {\r\n\t\t\t\t\tpoly.options.original.className.split(' ').forEach(function (className) {\r\n\t\t\t\t\t\tL.DomUtil.removeClass(path, className);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tpoly.options.editing.className.split(' ').forEach(function (className) {\r\n\t\t\t\t\tL.DomUtil.addClass(path, className);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpoly.setStyle(poly.options.editing);\r\n\r\n\t\tif (this._poly._map) {\r\n\r\n\t\t\tthis._map = this._poly._map; // Set map\r\n\r\n\t\t\tif (!this._markerGroup) {\r\n\t\t\t\tthis._initMarkers();\r\n\t\t\t}\r\n\t\t\tthis._poly._map.addLayer(this._markerGroup);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler.\r\n\tremoveHooks: function () {\r\n\t\tvar poly = this._poly;\r\n\t\tvar path = poly._path;\r\n\r\n\t\tif (path) {\r\n\t\t\tif (poly.options.editing && poly.options.editing.className) {\r\n\t\t\t\tpoly.options.editing.className.split(' ').forEach(function (className) {\r\n\t\t\t\t\tL.DomUtil.removeClass(path, className);\r\n\t\t\t\t});\r\n\t\t\t\tif (poly.options.original.className) {\r\n\t\t\t\t\tpoly.options.original.className.split(' ').forEach(function (className) {\r\n\t\t\t\t\t\tL.DomUtil.addClass(path, className);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpoly.setStyle(poly.options.original);\r\n\r\n\t\tif (poly._map) {\r\n\t\t\tpoly._map.removeLayer(this._markerGroup);\r\n\t\t\tdelete this._markerGroup;\r\n\t\t\tdelete this._markers;\r\n\t\t}\r\n\t},\r\n\r\n\t// @method updateMarkers(): void\r\n\t// Clear markers and update their location\r\n\tupdateMarkers: function () {\r\n\t\tthis._markerGroup.clearLayers();\r\n\t\tthis._initMarkers();\r\n\t},\r\n\r\n\t_initMarkers: function () {\r\n\t\tif (!this._markerGroup) {\r\n\t\t\tthis._markerGroup = new L.LayerGroup();\r\n\t\t}\r\n\t\tthis._markers = [];\r\n\r\n\t\tvar latlngs = this._defaultShape(),\r\n\t\t\ti, j, len, marker;\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\r\n\t\t\tmarker = this._createMarker(latlngs[i], i);\r\n\t\t\tmarker.on('click', this._onMarkerClick, this);\r\n\t\t\tmarker.on('contextmenu', this._onContextMenu, this);\r\n\t\t\tthis._markers.push(marker);\r\n\t\t}\r\n\r\n\t\tvar markerLeft, markerRight;\r\n\r\n\t\tfor (i = 0, j = len - 1; i < len; j = i++) {\r\n\t\t\tif (i === 0 && !(L.Polygon && (this._poly instanceof L.Polygon))) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tmarkerLeft = this._markers[j];\r\n\t\t\tmarkerRight = this._markers[i];\r\n\r\n\t\t\tthis._createMiddleMarker(markerLeft, markerRight);\r\n\t\t\tthis._updatePrevNext(markerLeft, markerRight);\r\n\t\t}\r\n\t},\r\n\r\n\t_createMarker: function (latlng, index) {\r\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\r\n\t\tvar marker = new L.Marker.Touch(latlng, {\r\n\t\t\tdraggable: true,\r\n\t\t\ticon: this.options.icon,\r\n\t\t});\r\n\r\n\t\tmarker._origLatLng = latlng;\r\n\t\tmarker._index = index;\r\n\r\n\t\tmarker\r\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\r\n\t\t\t.on('drag', this._onMarkerDrag, this)\r\n\t\t\t.on('dragend', this._fireEdit, this)\r\n\t\t\t.on('touchmove', this._onTouchMove, this)\r\n\t\t\t.on('touchend', this._fireEdit, this)\r\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t.on('MSPointerUp', this._fireEdit, this);\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\r\n\t\treturn marker;\r\n\t},\r\n\r\n\t_onMarkerDragStart: function () {\r\n\t\tthis._poly.fire('editstart');\r\n\t},\r\n\r\n\t_spliceLatLngs: function () {\r\n\t\tvar latlngs = this._defaultShape();\r\n\t\tvar removed = [].splice.apply(latlngs, arguments);\r\n\t\tthis._poly._convertLatLngs(latlngs, true);\r\n\t\tthis._poly.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\t_removeMarker: function (marker) {\r\n\t\tvar i = marker._index;\r\n\r\n\t\tthis._markerGroup.removeLayer(marker);\r\n\t\tthis._markers.splice(i, 1);\r\n\t\tthis._spliceLatLngs(i, 1);\r\n\t\tthis._updateIndexes(i, -1);\r\n\r\n\t\tmarker\r\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\r\n\t\t\t.off('drag', this._onMarkerDrag, this)\r\n\t\t\t.off('dragend', this._fireEdit, this)\r\n\t\t\t.off('touchmove', this._onMarkerDrag, this)\r\n\t\t\t.off('touchend', this._fireEdit, this)\r\n\t\t\t.off('click', this._onMarkerClick, this)\r\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t.off('MSPointerUp', this._fireEdit, this);\r\n\t},\r\n\r\n\t_fireEdit: function () {\r\n\t\tthis._poly.edited = true;\r\n\t\tthis._poly.fire('edit');\r\n\t\tthis._poly._map.fire(L.Draw.Event.EDITVERTEX, {layers: this._markerGroup, poly: this._poly});\r\n\t},\r\n\r\n\t_onMarkerDrag: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tvar poly = this._poly;\r\n\r\n\t\tvar oldOrigLatLng = L.LatLngUtil.cloneLatLng(marker._origLatLng);\r\n\t\tL.extend(marker._origLatLng, marker._latlng);\r\n\t\tif (poly.options.poly) {\r\n\t\t\tvar tooltip = poly._map._editTooltip; // Access the tooltip\r\n\r\n\t\t\t// If we don't allow intersections and the polygon intersects\r\n\t\t\tif (!poly.options.poly.allowIntersection && poly.intersects()) {\r\n\t\t\t\tL.extend(marker._origLatLng, oldOrigLatLng);\r\n\t\t\t\tmarker.setLatLng(oldOrigLatLng);\r\n\t\t\t\tvar originalColor = poly.options.color;\r\n\t\t\t\tpoly.setStyle({color: this.options.drawError.color});\r\n\t\t\t\tif (tooltip) {\r\n\t\t\t\t\ttooltip.updateContent({\r\n\t\t\t\t\t\ttext: L.drawLocal.draw.handlers.polyline.error\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Reset everything back to normal after a second\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\tpoly.setStyle({color: originalColor});\r\n\t\t\t\t\tif (tooltip) {\r\n\t\t\t\t\t\ttooltip.updateContent({\r\n\t\t\t\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\t\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 1000);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (marker._middleLeft) {\r\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\r\n\t\t}\r\n\t\tif (marker._middleRight) {\r\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\r\n\t\t}\r\n\r\n\t\t//refresh the bounds when draging\r\n\t\tthis._poly._bounds._southWest = L.latLng(Infinity, Infinity);\r\n\t\tthis._poly._bounds._northEast = L.latLng(-Infinity, -Infinity);\r\n\t\tvar latlngs = this._poly.getLatLngs();\r\n\t\tthis._poly._convertLatLngs(latlngs, true);\r\n\t\tthis._poly.redraw();\r\n\t\tthis._poly.fire('editdrag');\r\n\t},\r\n\r\n\t_onMarkerClick: function (e) {\r\n\r\n\t\tvar minPoints = L.Polygon && (this._poly instanceof L.Polygon) ? 4 : 3,\r\n\t\t\tmarker = e.target;\r\n\r\n\t\t// If removing this point would create an invalid polyline/polygon don't remove\r\n\t\tif (this._defaultShape().length < minPoints) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// remove the marker\r\n\t\tthis._removeMarker(marker);\r\n\r\n\t\t// update prev/next links of adjacent markers\r\n\t\tthis._updatePrevNext(marker._prev, marker._next);\r\n\r\n\t\t// remove ghost markers near the removed marker\r\n\t\tif (marker._middleLeft) {\r\n\t\t\tthis._markerGroup.removeLayer(marker._middleLeft);\r\n\t\t}\r\n\t\tif (marker._middleRight) {\r\n\t\t\tthis._markerGroup.removeLayer(marker._middleRight);\r\n\t\t}\r\n\r\n\t\t// create a ghost marker in place of the removed one\r\n\t\tif (marker._prev && marker._next) {\r\n\t\t\tthis._createMiddleMarker(marker._prev, marker._next);\r\n\r\n\t\t} else if (!marker._prev) {\r\n\t\t\tmarker._next._middleLeft = null;\r\n\r\n\t\t} else if (!marker._next) {\r\n\t\t\tmarker._prev._middleRight = null;\r\n\t\t}\r\n\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_onContextMenu: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tvar poly = this._poly;\r\n\t\tthis._poly._map.fire(L.Draw.Event.MARKERCONTEXT, {marker: marker, layers: this._markerGroup, poly: this._poly});\r\n\t\tL.DomEvent.stopPropagation;\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\r\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\r\n\t\t\tmarker = e.target;\r\n\r\n\t\tL.extend(marker._origLatLng, latlng);\r\n\r\n\t\tif (marker._middleLeft) {\r\n\t\t\tmarker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\r\n\t\t}\r\n\t\tif (marker._middleRight) {\r\n\t\t\tmarker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\r\n\t\t}\r\n\r\n\t\tthis._poly.redraw();\r\n\t\tthis.updateMarkers();\r\n\t},\r\n\r\n\t_updateIndexes: function (index, delta) {\r\n\t\tthis._markerGroup.eachLayer(function (marker) {\r\n\t\t\tif (marker._index > index) {\r\n\t\t\t\tmarker._index += delta;\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_createMiddleMarker: function (marker1, marker2) {\r\n\t\tvar latlng = this._getMiddleLatLng(marker1, marker2),\r\n\t\t\tmarker = this._createMarker(latlng),\r\n\t\t\tonClick,\r\n\t\t\tonDragStart,\r\n\t\t\tonDragEnd;\r\n\r\n\t\tmarker.setOpacity(0.6);\r\n\r\n\t\tmarker1._middleRight = marker2._middleLeft = marker;\r\n\r\n\t\tonDragStart = function () {\r\n\t\t\tmarker.off('touchmove', onDragStart, this);\r\n\t\t\tvar i = marker2._index;\r\n\r\n\t\t\tmarker._index = i;\r\n\r\n\t\t\tmarker\r\n\t\t\t\t.off('click', onClick, this)\r\n\t\t\t\t.on('click', this._onMarkerClick, this);\r\n\r\n\t\t\tlatlng.lat = marker.getLatLng().lat;\r\n\t\t\tlatlng.lng = marker.getLatLng().lng;\r\n\t\t\tthis._spliceLatLngs(i, 0, latlng);\r\n\t\t\tthis._markers.splice(i, 0, marker);\r\n\r\n\t\t\tmarker.setOpacity(1);\r\n\r\n\t\t\tthis._updateIndexes(i, 1);\r\n\t\t\tmarker2._index++;\r\n\t\t\tthis._updatePrevNext(marker1, marker);\r\n\t\t\tthis._updatePrevNext(marker, marker2);\r\n\r\n\t\t\tthis._poly.fire('editstart');\r\n\t\t};\r\n\r\n\t\tonDragEnd = function () {\r\n\t\t\tmarker.off('dragstart', onDragStart, this);\r\n\t\t\tmarker.off('dragend', onDragEnd, this);\r\n\t\t\tmarker.off('touchmove', onDragStart, this);\r\n\r\n\t\t\tthis._createMiddleMarker(marker1, marker);\r\n\t\t\tthis._createMiddleMarker(marker, marker2);\r\n\t\t};\r\n\r\n\t\tonClick = function () {\r\n\t\t\tonDragStart.call(this);\r\n\t\t\tonDragEnd.call(this);\r\n\t\t\tthis._fireEdit();\r\n\t\t};\r\n\r\n\t\tmarker\r\n\t\t\t.on('click', onClick, this)\r\n\t\t\t.on('dragstart', onDragStart, this)\r\n\t\t\t.on('dragend', onDragEnd, this)\r\n\t\t\t.on('touchmove', onDragStart, this);\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\t},\r\n\r\n\t_updatePrevNext: function (marker1, marker2) {\r\n\t\tif (marker1) {\r\n\t\t\tmarker1._next = marker2;\r\n\t\t}\r\n\t\tif (marker2) {\r\n\t\t\tmarker2._prev = marker1;\r\n\t\t}\r\n\t},\r\n\r\n\t_getMiddleLatLng: function (marker1, marker2) {\r\n\t\tvar map = this._poly._map,\r\n\t\t\tp1 = map.project(marker1.getLatLng()),\r\n\t\t\tp2 = map.project(marker2.getLatLng());\r\n\r\n\t\treturn map.unproject(p1._add(p2)._divideBy(2));\r\n\t}\r\n});\r\n\r\nL.Polyline.addInitHook(function () {\r\n\r\n\t// Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit\r\n\tif (this.editing) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (L.Edit.Poly) {\r\n\r\n\t\tthis.editing = new L.Edit.Poly(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on('add', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on('remove', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.SimpleShape\r\n * @aka Edit.SimpleShape\r\n */\r\nL.Edit.SimpleShape = L.Handler.extend({\r\n\toptions: {\r\n\t\tmoveIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move'\r\n\t\t}),\r\n\t\tresizeIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(8, 8),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize'\r\n\t\t}),\r\n\t\ttouchMoveIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon'\r\n\t\t}),\r\n\t\ttouchResizeIcon: new L.DivIcon({\r\n\t\t\ticonSize: new L.Point(20, 20),\r\n\t\t\tclassName: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon'\r\n\t\t}),\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (shape, options) {\r\n\t\t// if touch, switch to touch icon\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tthis.options.moveIcon = this.options.touchMoveIcon;\r\n\t\t\tthis.options.resizeIcon = this.options.touchResizeIcon;\r\n\t\t}\r\n\r\n\t\tthis._shape = shape;\r\n\t\tL.Util.setOptions(this, options);\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar shape = this._shape;\r\n\t\tif (this._shape._map) {\r\n\t\t\tthis._map = this._shape._map;\r\n\t\t\tshape.setStyle(shape.options.editing);\r\n\r\n\t\t\tif (shape._map) {\r\n\t\t\t\tthis._map = shape._map;\r\n\t\t\t\tif (!this._markerGroup) {\r\n\t\t\t\t\tthis._initMarkers();\r\n\t\t\t\t}\r\n\t\t\t\tthis._map.addLayer(this._markerGroup);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tvar shape = this._shape;\r\n\r\n\t\tshape.setStyle(shape.options.original);\r\n\r\n\t\tif (shape._map) {\r\n\t\t\tthis._unbindMarker(this._moveMarker);\r\n\r\n\t\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\t\tthis._unbindMarker(this._resizeMarkers[i]);\r\n\t\t\t}\r\n\t\t\tthis._resizeMarkers = null;\r\n\r\n\t\t\tthis._map.removeLayer(this._markerGroup);\r\n\t\t\tdelete this._markerGroup;\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t// @method updateMarkers(): void\r\n\t// Remove the edit markers from this layer\r\n\tupdateMarkers: function () {\r\n\t\tthis._markerGroup.clearLayers();\r\n\t\tthis._initMarkers();\r\n\t},\r\n\r\n\t_initMarkers: function () {\r\n\t\tif (!this._markerGroup) {\r\n\t\t\tthis._markerGroup = new L.LayerGroup();\r\n\t\t}\r\n\r\n\t\t// Create center marker\r\n\t\tthis._createMoveMarker();\r\n\r\n\t\t// Create edge marker\r\n\t\tthis._createResizeMarker();\r\n\t},\r\n\r\n\t_createMoveMarker: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_createMarker: function (latlng, icon) {\r\n\t\t// Extending L.Marker in TouchEvents.js to include touch.\r\n\t\tvar marker = new L.Marker.Touch(latlng, {\r\n\t\t\tdraggable: true,\r\n\t\t\ticon: icon,\r\n\t\t\tzIndexOffset: 10\r\n\t\t});\r\n\r\n\t\tthis._bindMarker(marker);\r\n\r\n\t\tthis._markerGroup.addLayer(marker);\r\n\r\n\t\treturn marker;\r\n\t},\r\n\r\n\t_bindMarker: function (marker) {\r\n\t\tmarker\r\n\t\t\t.on('dragstart', this._onMarkerDragStart, this)\r\n\t\t\t.on('drag', this._onMarkerDrag, this)\r\n\t\t\t.on('dragend', this._onMarkerDragEnd, this)\r\n\t\t\t.on('touchstart', this._onTouchStart, this)\r\n\t\t\t.on('touchmove', this._onTouchMove, this)\r\n\t\t\t.on('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t.on('touchend', this._onTouchEnd, this)\r\n\t\t\t.on('MSPointerUp', this._onTouchEnd, this);\r\n\t},\r\n\r\n\t_unbindMarker: function (marker) {\r\n\t\tmarker\r\n\t\t\t.off('dragstart', this._onMarkerDragStart, this)\r\n\t\t\t.off('drag', this._onMarkerDrag, this)\r\n\t\t\t.off('dragend', this._onMarkerDragEnd, this)\r\n\t\t\t.off('touchstart', this._onTouchStart, this)\r\n\t\t\t.off('touchmove', this._onTouchMove, this)\r\n\t\t\t.off('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t.off('touchend', this._onTouchEnd, this)\r\n\t\t\t.off('MSPointerUp', this._onTouchEnd, this);\r\n\t},\r\n\r\n\t_onMarkerDragStart: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(0);\r\n\r\n\t\tthis._shape.fire('editstart');\r\n\t},\r\n\r\n\t_fireEdit: function () {\r\n\t\tthis._shape.edited = true;\r\n\t\tthis._shape.fire('edit');\r\n\t},\r\n\r\n\t_onMarkerDrag: function (e) {\r\n\t\tvar marker = e.target,\r\n\t\t\tlatlng = marker.getLatLng();\r\n\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tthis._move(latlng);\r\n\t\t} else {\r\n\t\t\tthis._resize(latlng);\r\n\t\t}\r\n\r\n\t\tthis._shape.redraw();\r\n\t\tthis._shape.fire('editdrag');\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(1);\r\n\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_onTouchStart: function (e) {\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\r\n\r\n\t\tif (typeof(this._getCorners) === 'function') {\r\n\t\t\t// Save a reference to the opposite point\r\n\t\t\tvar corners = this._getCorners(),\r\n\t\t\t\tmarker = e.target,\r\n\t\t\t\tcurrentCornerIndex = marker._cornerIndex;\r\n\r\n\t\t\tmarker.setOpacity(0);\r\n\r\n\t\t\t// Copyed from Edit.Rectangle.js line 23 _onMarkerDragStart()\r\n\t\t\t// Latlng is null otherwise.\r\n\t\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\r\n\t\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\r\n\t\t}\r\n\r\n\t\tthis._shape.fire('editstart');\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tvar layerPoint = this._map.mouseEventToLayerPoint(e.originalEvent.touches[0]),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint),\r\n\t\t\tmarker = e.target;\r\n\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tthis._move(latlng);\r\n\t\t} else {\r\n\t\t\tthis._resize(latlng);\r\n\t\t}\r\n\r\n\t\tthis._shape.redraw();\r\n\r\n\t\t// prevent touchcancel in IOS\r\n\t\t// e.preventDefault();\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_onTouchEnd: function (e) {\r\n\t\tvar marker = e.target;\r\n\t\tmarker.setOpacity(1);\r\n\t\tthis.updateMarkers();\r\n\t\tthis._fireEdit();\r\n\t},\r\n\r\n\t_move: function () {\r\n\t\t// Children override\r\n\t},\r\n\r\n\t_resize: function () {\r\n\t\t// Children override\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.Rectangle\r\n * @aka Edit.Rectangle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.Rectangle = L.Edit.SimpleShape.extend({\r\n\t_createMoveMarker: function () {\r\n\t\tvar bounds = this._shape.getBounds(),\r\n\t\t\tcenter = bounds.getCenter();\r\n\r\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\tvar corners = this._getCorners();\r\n\r\n\t\tthis._resizeMarkers = [];\r\n\r\n\t\tfor (var i = 0, l = corners.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon));\r\n\t\t\t// Monkey in the corner index as we will need to know this for dragging\r\n\t\t\tthis._resizeMarkers[i]._cornerIndex = i;\r\n\t\t}\r\n\t},\r\n\r\n\t_onMarkerDragStart: function (e) {\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);\r\n\r\n\t\t// Save a reference to the opposite point\r\n\t\tvar corners = this._getCorners(),\r\n\t\t\tmarker = e.target,\r\n\t\t\tcurrentCornerIndex = marker._cornerIndex;\r\n\r\n\t\tthis._oppositeCorner = corners[(currentCornerIndex + 2) % 4];\r\n\r\n\t\tthis._toggleCornerMarkers(0, currentCornerIndex);\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar marker = e.target,\r\n\t\t\tbounds, center;\r\n\r\n\t\t// Reset move marker position to the center\r\n\t\tif (marker === this._moveMarker) {\r\n\t\t\tbounds = this._shape.getBounds();\r\n\t\t\tcenter = bounds.getCenter();\r\n\r\n\t\t\tmarker.setLatLng(center);\r\n\t\t}\r\n\r\n\t\tthis._toggleCornerMarkers(1);\r\n\r\n\t\tthis._repositionCornerMarkers();\r\n\r\n\t\tL.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);\r\n\t},\r\n\r\n\t_move: function (newCenter) {\r\n\t\tvar latlngs = this._shape._defaultShape ? this._shape._defaultShape() : this._shape.getLatLngs(),\r\n\t\t\tbounds = this._shape.getBounds(),\r\n\t\t\tcenter = bounds.getCenter(),\r\n\t\t\toffset, newLatLngs = [];\r\n\r\n\t\t// Offset the latlngs to the new center\r\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\r\n\t\t\toffset = [latlngs[i].lat - center.lat, latlngs[i].lng - center.lng];\r\n\t\t\tnewLatLngs.push([newCenter.lat + offset[0], newCenter.lng + offset[1]]);\r\n\t\t}\r\n\r\n\t\tthis._shape.setLatLngs(newLatLngs);\r\n\r\n\t\t// Reposition the resize markers\r\n\t\tthis._repositionCornerMarkers();\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tvar bounds;\r\n\r\n\t\t// Update the shape based on the current position of this corner and the opposite point\r\n\t\tthis._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner));\r\n\r\n\t\t// Reposition the move marker\r\n\t\tbounds = this._shape.getBounds();\r\n\t\tthis._moveMarker.setLatLng(bounds.getCenter());\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\r\n\t},\r\n\r\n\t_getCorners: function () {\r\n\t\tvar bounds = this._shape.getBounds(),\r\n\t\t\tnw = bounds.getNorthWest(),\r\n\t\t\tne = bounds.getNorthEast(),\r\n\t\t\tse = bounds.getSouthEast(),\r\n\t\t\tsw = bounds.getSouthWest();\r\n\r\n\t\treturn [nw, ne, se, sw];\r\n\t},\r\n\r\n\t_toggleCornerMarkers: function (opacity) {\r\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers[i].setOpacity(opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_repositionCornerMarkers: function () {\r\n\t\tvar corners = this._getCorners();\r\n\r\n\t\tfor (var i = 0, l = this._resizeMarkers.length; i < l; i++) {\r\n\t\t\tthis._resizeMarkers[i].setLatLng(corners[i]);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Rectangle.addInitHook(function () {\r\n\tif (L.Edit.Rectangle) {\r\n\t\tthis.editing = new L.Edit.Rectangle(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.CircleMarker\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.SimpleShape\r\n */\r\nL.Edit.CircleMarker = L.Edit.SimpleShape.extend({\r\n\t_createMoveMarker: function () {\r\n\t\tvar center = this._shape.getLatLng();\r\n\t\tthis._map._editTooltip = new L.Draw.Tooltip(this._map);\r\n\t\tthis._moveMarker = this._createMarker(center, this.options.moveIcon);\r\n\t},\r\n\r\n\t_createResizeMarker: function () {\r\n\t\t// To avoid an undefined check in L.Edit.SimpleShape.removeHooks\r\n\t\tthis._resizeMarkers = [];\r\n\t},\r\n\r\n\t_move: function (latlng) {\r\n\t\tif (this._resizeMarkers.length) {\r\n\t\t\tvar resizemarkerPoint = this._getResizeMarkerPoint(latlng);\r\n\t\t\t// Move the resize marker\r\n\t\t\tthis._resizeMarkers[0].setLatLng(resizemarkerPoint);\r\n\t\t}\r\n\r\n\t\t// Move the circle\r\n\t\tthis._shape.setLatLng(latlng);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: this._shape});\r\n\t},\r\n});\r\n\r\nL.CircleMarker.addInitHook(function () {\r\n\tif (L.Edit.CircleMarker) {\r\n\t\tthis.editing = new L.Edit.CircleMarker(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n\r\n\tthis.on('add', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.addHooks();\r\n\t\t}\r\n\t});\r\n\r\n\tthis.on('remove', function () {\r\n\t\tif (this.editing && this.editing.enabled()) {\r\n\t\t\tthis.editing.removeHooks();\r\n\t\t}\r\n\t});\r\n});\r\n","L.Edit = L.Edit || {};\r\n/**\r\n * @class L.Edit.Circle\r\n * @aka Edit.Circle\r\n * @inherits L.Edit.CircleMarker\r\n */\r\nL.Edit.Circle = L.Edit.CircleMarker.extend({\r\n\r\n\t_createResizeMarker: function () {\r\n\t\tvar center = this._shape.getLatLng(),\r\n\t\t\tresizemarkerPoint = this._getResizeMarkerPoint(center);\r\n\r\n\t\tthis._resizeMarkers = [];\r\n\t\tthis._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));\r\n\t},\r\n\r\n\t_getResizeMarkerPoint: function (latlng) {\r\n\t\t// From L.shape.getBounds()\r\n\t\tvar delta = this._shape._radius * Math.cos(Math.PI / 4),\r\n\t\t\tpoint = this._map.project(latlng);\r\n\t\treturn this._map.unproject([point.x + delta, point.y - delta]);\r\n\t},\r\n\r\n\t_resize: function (latlng) {\r\n\t\tvar moveLatLng = this._moveMarker.getLatLng();\r\n\r\n\t\t// Calculate the radius based on the version\r\n\t\tif (L.GeometryUtil.isVersion07x()) {\r\n\t\t\tradius = moveLatLng.distanceTo(latlng);\r\n\t\t} else {\r\n\t\t\tradius = this._map.distance(moveLatLng, latlng);\r\n\t\t}\r\n\t\tthis._shape.setRadius(radius);\r\n\r\n\t\tif (this._map._editTooltip) {\r\n\t\t\tthis._map._editTooltip.updatePosition(latlng);\r\n\t\t\tthis._map._editTooltip.updateContent({\r\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.subtext + '<br />' + L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\t\tsubtext: L.drawLocal.draw.handlers.circle.radius + ': ' +\r\n\t\t\t\tL.GeometryUtil.readableDistance(radius, true, this.options.feet, this.options.nautic)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._shape.setRadius(radius);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITRESIZE, {layer: this._shape});\r\n\t}\r\n});\r\n\r\nL.Circle.addInitHook(function () {\r\n\tif (L.Edit.Circle) {\r\n\t\tthis.editing = new L.Edit.Circle(this);\r\n\r\n\t\tif (this.options.editable) {\r\n\t\t\tthis.editing.enable();\r\n\t\t}\r\n\t}\r\n});\r\n","L.Map.mergeOptions({\r\n\ttouchExtend: true\r\n});\r\n\r\n/**\r\n * @class L.Map.TouchExtend\r\n * @aka TouchExtend\r\n */\r\nL.Map.TouchExtend = L.Handler.extend({\r\n\r\n\t// @method initialize(): void\r\n\t// Sets TouchExtend private accessor variables\r\n\tinitialize: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._container = map._container;\r\n\t\tthis._pane = map._panes.overlayPane;\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Adds dom listener events to the map container\r\n\taddHooks: function () {\r\n\t\tL.DomEvent.on(this._container, 'touchstart', this._onTouchStart, this);\r\n\t\tL.DomEvent.on(this._container, 'touchend', this._onTouchEnd, this);\r\n\t\tL.DomEvent.on(this._container, 'touchmove', this._onTouchMove, this);\r\n\t\tif (this._detectIE()) {\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerDown', this._onTouchStart, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerUp', this._onTouchEnd, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerMove', this._onTouchMove, this);\r\n\t\t\tL.DomEvent.on(this._container, 'MSPointerCancel', this._onTouchCancel, this);\r\n\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(this._container, 'touchcancel', this._onTouchCancel, this);\r\n\t\t\tL.DomEvent.on(this._container, 'touchleave', this._onTouchLeave, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Removes dom listener events from the map container\r\n\tremoveHooks: function () {\r\n\t\tL.DomEvent.off(this._container, 'touchstart', this._onTouchStart, this);\r\n\t\tL.DomEvent.off(this._container, 'touchend', this._onTouchEnd, this);\r\n\t\tL.DomEvent.off(this._container, 'touchmove', this._onTouchMove, this);\r\n\t\tif (this._detectIE()) {\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerDown', this._onTouchStart, this);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerUp', this._onTouchEnd, this);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerMove', this._onTouchMove, this);\r\n\t\t\tL.DomEvent.off(this._container, 'MSPointerCancel', this._onTouchCancel, this);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.off(this._container, 'touchcancel', this._onTouchCancel, this);\r\n\t\t\tL.DomEvent.off(this._container, 'touchleave', this._onTouchLeave, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_touchEvent: function (e, type) {\r\n\t\t// #TODO: fix the pageX error that is do a bug in Android where a single touch triggers two click events\r\n\t\t// _filterClick is what leaflet uses as a workaround.\r\n\t\t// This is a problem with more things than just android. Another problem is touchEnd has no touches in\r\n\t\t// its touch list.\r\n\t\tvar touchEvent = {};\r\n\t\tif (typeof e.touches !== 'undefined') {\r\n\t\t\tif (!e.touches.length) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttouchEvent = e.touches[0];\r\n\t\t} else if (e.pointerType === 'touch') {\r\n\t\t\ttouchEvent = e;\r\n\t\t\tif (!this._filterClick(e)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this._map.mouseEventToContainerPoint(touchEvent),\r\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis._map.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\tpageX: touchEvent.pageX,\r\n\t\t\tpageY: touchEvent.pageY,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t/** Borrowed from Leaflet and modified for bool ops **/\r\n\t_filterClick: function (e) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_onTouchStart: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchstart';\r\n\t\tthis._touchEvent(e, type);\r\n\r\n\t},\r\n\r\n\t_onTouchEnd: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchend';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchCancel: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchcancel';\r\n\t\tif (this._detectIE()) {\r\n\t\t\ttype = 'pointercancel';\r\n\t\t}\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchLeave: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchleave';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tif (!this._map._loaded) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar type = 'touchmove';\r\n\t\tthis._touchEvent(e, type);\r\n\t},\r\n\r\n\t_detectIE: function () {\r\n\t\tvar ua = window.navigator.userAgent;\r\n\r\n\t\tvar msie = ua.indexOf('MSIE ');\r\n\t\tif (msie > 0) {\r\n\t\t\t// IE 10 or older => return version number\r\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n\t\t}\r\n\r\n\t\tvar trident = ua.indexOf('Trident/');\r\n\t\tif (trident > 0) {\r\n\t\t\t// IE 11 => return version number\r\n\t\t\tvar rv = ua.indexOf('rv:');\r\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n\t\t}\r\n\r\n\t\tvar edge = ua.indexOf('Edge/');\r\n\t\tif (edge > 0) {\r\n\t\t\t// IE 12 => return version number\r\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n\t\t}\r\n\r\n\t\t// other browser\r\n\t\treturn false;\r\n\t}\r\n});\r\n\r\nL.Map.addInitHook('addHandler', 'touchExtend', L.Map.TouchExtend);\r\n\r\n\r\n/**\r\n * @class L.Marker.Touch\r\n * @aka Marker.Touch\r\n *\r\n * This isn't full Touch support. This is just to get markers to also support dom touch events after creation\r\n * #TODO: find a better way of getting markers to support touch.\r\n */\r\nL.Marker.Touch = L.Marker.extend({\r\n\r\n\t_initInteraction: function () {\r\n\t\tif (!this.addInteractiveTarget) {\r\n\t\t\t// 0.7.x support\r\n\t\t\treturn this._initInteractionLegacy();\r\n\t\t}\r\n\t\t// TODO this may need be updated to re-add touch events for 1.0+\r\n\t\treturn L.Marker.prototype._initInteraction.apply(this);\r\n\t},\r\n\r\n\t// This is an exact copy of https://github.com/Leaflet/Leaflet/blob/v0.7/src/layer/marker/Marker.js\r\n\t// with the addition of the touch events\r\n\t_initInteractionLegacy: function () {\r\n\r\n\t\tif (!this.options.clickable) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t\tevents = ['dblclick',\r\n\t\t\t\t'mousedown',\r\n\t\t\t\t'mouseover',\r\n\t\t\t\t'mouseout',\r\n\t\t\t\t'contextmenu',\r\n\t\t\t\t'touchstart',\r\n\t\t\t\t'touchend',\r\n\t\t\t\t'touchmove'];\r\n\t\tif (this._detectIE) {\r\n\t\t\tevents.concat(['MSPointerDown',\r\n\t\t\t\t'MSPointerUp',\r\n\t\t\t\t'MSPointerMove',\r\n\t\t\t\t'MSPointerCancel']);\r\n\t\t} else {\r\n\t\t\tevents.concat(['touchcancel']);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_detectIE: function () {\r\n\t\tvar ua = window.navigator.userAgent;\r\n\r\n\t\tvar msie = ua.indexOf('MSIE ');\r\n\t\tif (msie > 0) {\r\n\t\t\t// IE 10 or older => return version number\r\n\t\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\r\n\t\t}\r\n\r\n\t\tvar trident = ua.indexOf('Trident/');\r\n\t\tif (trident > 0) {\r\n\t\t\t// IE 11 => return version number\r\n\t\t\tvar rv = ua.indexOf('rv:');\r\n\t\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\r\n\t\t}\r\n\r\n\t\tvar edge = ua.indexOf('Edge/');\r\n\t\tif (edge > 0) {\r\n\t\t\t// IE 12 => return version number\r\n\t\t\treturn parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\r\n\t\t}\r\n\r\n\t\t// other browser\r\n\t\treturn false;\r\n\t}\r\n});\r\n","/**\r\n * @class L.LatLngUtil\r\n * @aka LatLngUtil\r\n */\r\nL.LatLngUtil = {\r\n\t// Clones a LatLngs[], returns [][]\r\n\r\n\t// @method cloneLatLngs(LatLngs[]): L.LatLngs[]\r\n\t// Clone the latLng point or points or nested points and return an array with those points\r\n\tcloneLatLngs: function (latlngs) {\r\n\t\tvar clone = [];\r\n\t\tfor (var i = 0, l = latlngs.length; i < l; i++) {\r\n\t\t\t// Check for nested array (Polyline/Polygon)\r\n\t\t\tif (Array.isArray(latlngs[i])) {\r\n\t\t\t\tclone.push(L.LatLngUtil.cloneLatLngs(latlngs[i]));\r\n\t\t\t} else {\r\n\t\t\t\tclone.push(this.cloneLatLng(latlngs[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn clone;\r\n\t},\r\n\r\n\t// @method cloneLatLng(LatLng): L.LatLng\r\n\t// Clone the latLng and return a new LatLng object.\r\n\tcloneLatLng: function (latlng) {\r\n\t\treturn L.latLng(latlng.lat, latlng.lng);\r\n\t}\r\n};\r\n","(function () {\r\n\r\n\tvar defaultPrecision = {\r\n\t\tkm: 2,\r\n\t\tha: 2,\r\n\t\tm: 0,\r\n\t\tmi: 2,\r\n\t\tac: 2,\r\n\t\tyd: 0,\r\n\t\tft: 0,\r\n\t\tnm: 2\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * @class L.GeometryUtil\r\n\t * @aka GeometryUtil\r\n\t */\r\n\tL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\r\n\t\t// Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270\r\n\r\n\t\t// @method geodesicArea(): number\r\n\t\tgeodesicArea: function (latLngs) {\r\n\t\t\tvar pointsCount = latLngs.length,\r\n\t\t\t\tarea = 0.0,\r\n\t\t\t\td2r = Math.PI / 180,\r\n\t\t\t\tp1, p2;\r\n\r\n\t\t\tif (pointsCount > 2) {\r\n\t\t\t\tfor (var i = 0; i < pointsCount; i++) {\r\n\t\t\t\t\tp1 = latLngs[i];\r\n\t\t\t\t\tp2 = latLngs[(i + 1) % pointsCount];\r\n\t\t\t\t\tarea += ((p2.lng - p1.lng) * d2r) *\r\n\t\t\t\t\t\t(2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));\r\n\t\t\t\t}\r\n\t\t\t\tarea = area * 6378137.0 * 6378137.0 / 2.0;\r\n\t\t\t}\r\n\r\n\t\t\treturn Math.abs(area);\r\n\t\t},\r\n\r\n\t\t// @method formattedNumber(n, precision): string\r\n\t\t// Returns n in specified number format (if defined) and precision\r\n\t\tformattedNumber: function (n, precision) {\r\n\t\t\tvar formatted = parseFloat(n).toFixed(precision),\r\n\t\t\t\tformat = L.drawLocal.format && L.drawLocal.format.numeric,\r\n\t\t\t\tdelimiters = format && format.delimiters,\r\n\t\t\t\tthousands = delimiters && delimiters.thousands,\r\n\t\t\t\tdecimal = delimiters && delimiters.decimal;\r\n\r\n\t\t\tif (thousands || decimal) {\r\n\t\t\t\tvar splitValue = formatted.split('.');\r\n\t\t\t\tformatted = thousands ? splitValue[0].replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + thousands) : splitValue[0];\r\n\t\t\t\tdecimal = decimal || '.';\r\n\t\t\t\tif (splitValue.length > 1) {\r\n\t\t\t\t\tformatted = formatted + decimal + splitValue[1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn formatted;\r\n\t\t},\r\n\r\n\t\t// @method readableArea(area, isMetric, precision): string\r\n\t\t// Returns a readable area string in yards or metric.\r\n\t\t// The value will be rounded as defined by the precision option object.\r\n\t\treadableArea: function (area, isMetric, precision) {\r\n\t\t\tvar areaStr,\r\n\t\t\t\tunits,\r\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\r\n\r\n\t\t\tif (isMetric) {\r\n\t\t\t\tunits = ['ha', 'm'];\r\n\t\t\t\ttype = typeof isMetric;\r\n\t\t\t\tif (type === 'string') {\r\n\t\t\t\t\tunits = [isMetric];\r\n\t\t\t\t} else if (type !== 'boolean') {\r\n\t\t\t\t\tunits = isMetric;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (area >= 1000000 && units.indexOf('km') !== -1) {\r\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.000001, precision['km']) + ' km²';\r\n\t\t\t\t} else if (area >= 10000 && units.indexOf('ha') !== -1) {\r\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area * 0.0001, precision['ha']) + ' ha';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['m']) + ' m²';\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tarea /= 0.836127; // Square yards in 1 meter\r\n\r\n\t\t\t\tif (area >= 3097600) { //3097600 square yards in 1 square mile\r\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 3097600, precision['mi']) + ' mi²';\r\n\t\t\t\t} else if (area >= 4840) { //4840 square yards in 1 acre\r\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area / 4840, precision['ac']) + ' acres';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tareaStr = L.GeometryUtil.formattedNumber(area, precision['yd']) + ' yd²';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn areaStr;\r\n\t\t},\r\n\r\n\t\t// @method readableDistance(distance, units): string\r\n\t\t// Converts a metric distance to one of [ feet, nauticalMile, metric or yards ] string\r\n\t\t//\r\n\t\t// @alternative\r\n\t\t// @method readableDistance(distance, isMetric, useFeet, isNauticalMile, precision): string\r\n\t\t// Converts metric distance to distance string.\r\n\t\t// The value will be rounded as defined by the precision option object.\r\n\t\treadableDistance: function (distance, isMetric, isFeet, isNauticalMile, precision) {\r\n\t\t\tvar distanceStr,\r\n\t\t\t\tunits,\r\n\t\t\t\tprecision = L.Util.extend({}, defaultPrecision, precision);\r\n\r\n\t\t\tif (isMetric) {\r\n\t\t\t\tunits = typeof isMetric == 'string' ? isMetric : 'metric';\r\n\t\t\t} else if (isFeet) {\r\n\t\t\t\tunits = 'feet';\r\n\t\t\t} else if (isNauticalMile) {\r\n\t\t\t\tunits = 'nauticalMile';\r\n\t\t\t} else {\r\n\t\t\t\tunits = 'yards';\r\n\t\t\t}\r\n\r\n\t\t\tswitch (units) {\r\n\t\t\t\tcase 'metric':\r\n\t\t\t\t\t// show metres when distance is < 1km, then show km\r\n\t\t\t\t\tif (distance > 1000) {\r\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['km']) + ' km';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['m']) + ' m';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'feet':\r\n\t\t\t\t\tdistance *= 1.09361 * 3;\r\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['ft']) + ' ft';\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'nauticalMile':\r\n\t\t\t\t\tdistance *= 0.53996;\r\n\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1000, precision['nm']) + ' nm';\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'yards':\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tdistance *= 1.09361;\r\n\r\n\t\t\t\t\tif (distance > 1760) {\r\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance / 1760, precision['mi']) + ' miles';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdistanceStr = L.GeometryUtil.formattedNumber(distance, precision['yd']) + ' yd';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn distanceStr;\r\n\t\t},\r\n\r\n\t\t// @method isVersion07x(): boolean\r\n\t\t// Returns true if the Leaflet version is 0.7.x, false otherwise.\r\n\t\tisVersion07x: function () {\r\n\t\t\tvar version = L.version.split('.');\r\n\t\t\t//If Version is == 0.7.*\r\n\t\t\treturn parseInt(version[0], 10) === 0 && parseInt(version[1], 10) === 7;\r\n\t\t},\r\n\t});\r\n\r\n})();\r\n","/**\r\n * @class L.LineUtil\r\n * @aka Util\r\n * @aka L.Utils\r\n */\r\nL.Util.extend(L.LineUtil, {\r\n\r\n\t// @method segmentsIntersect(): boolean\r\n\t// Checks to see if two line segments intersect. Does not handle degenerate cases.\r\n\t// http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf\r\n\tsegmentsIntersect: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3) {\r\n\t\treturn this._checkCounterclockwise(p, p2, p3) !==\r\n\t\t\tthis._checkCounterclockwise(p1, p2, p3) &&\r\n\t\t\tthis._checkCounterclockwise(p, p1, p2) !==\r\n\t\t\tthis._checkCounterclockwise(p, p1, p3);\r\n\t},\r\n\r\n\t// check to see if points are in counterclockwise order\r\n\t_checkCounterclockwise: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Polyline\r\n * @aka Polyline\r\n */\r\nL.Polyline.include({\r\n\r\n\t// @method intersects(): boolean\r\n\t// Check to see if this polyline has any linesegments that intersect.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tintersects: function () {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0,\r\n\t\t\ti, p, p1;\r\n\r\n\t\tif (this._tooFewPointsForIntersection()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (i = len - 1; i >= 3; i--) {\r\n\t\t\tp = points[i - 1];\r\n\t\t\tp1 = points[i];\r\n\r\n\r\n\t\t\tif (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// @method newLatLngIntersects(): boolean\r\n\t// Check for intersection if new latlng was added to this polyline.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tnewLatLngIntersects: function (latlng, skipFirst) {\r\n\t\t// Cannot check a polyline for intersecting lats/lngs when not added to the map\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\r\n\t},\r\n\r\n\t// @method newPointIntersects(): boolean\r\n\t// Check for intersection if new point was added to this polyline.\r\n\t// newPoint must be a layer point.\r\n\t// NOTE: does not support detecting intersection for degenerate cases.\r\n\tnewPointIntersects: function (newPoint, skipFirst) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0,\r\n\t\t\tlastPoint = points ? points[len - 1] : null,\r\n\t\t\t// The previous previous line segment. Previous line segment doesn't need testing.\r\n\t\t\tmaxIndex = len - 2;\r\n\r\n\t\tif (this._tooFewPointsForIntersection(1)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\r\n\t},\r\n\r\n\t// Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).\r\n\t// Cannot have intersection when < 3 line segments (< 4 points)\r\n\t_tooFewPointsForIntersection: function (extraPoints) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tlen = points ? points.length : 0;\r\n\t\t// Increment length by extraPoints if present\r\n\t\tlen += extraPoints || 0;\r\n\r\n\t\treturn !points || len <= 3;\r\n\t},\r\n\r\n\t// Checks a line segment intersections with any line segments before its predecessor.\r\n\t// Don't need to check the predecessor as will never intersect.\r\n\t_lineSegmentsIntersectsRange: function (p, p1, maxIndex, minIndex) {\r\n\t\tvar points = this._getProjectedPoints(),\r\n\t\t\tp2, p3;\r\n\r\n\t\tminIndex = minIndex || 0;\r\n\r\n\t\t// Check all previous line segments (beside the immediately previous) for intersections\r\n\t\tfor (var j = maxIndex; j > minIndex; j--) {\r\n\t\t\tp2 = points[j - 1];\r\n\t\t\tp3 = points[j];\r\n\r\n\t\t\tif (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_getProjectedPoints: function () {\r\n\t\tif (!this._defaultShape) {\r\n\t\t\treturn this._originalPoints;\r\n\t\t}\r\n\t\tvar points = [],\r\n\t\t\t_shape = this._defaultShape();\r\n\r\n\t\tfor (var i = 0; i < _shape.length; i++) {\r\n\t\t\tpoints.push(this._map.latLngToLayerPoint(_shape[i]));\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n});\r\n","/**\r\n * @class L.Polygon\r\n * @aka Polygon\r\n */\r\nL.Polygon.include({\r\n\r\n\t// @method intersects(): boolean\r\n\t// Checks a polygon for any intersecting line segments. Ignores holes.\r\n\tintersects: function () {\r\n\t\tvar polylineIntersects,\r\n\t\t\tpoints = this._getProjectedPoints(),\r\n\t\t\tlen, firstPoint, lastPoint, maxIndex;\r\n\r\n\t\tif (this._tooFewPointsForIntersection()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tpolylineIntersects = L.Polyline.prototype.intersects.call(this);\r\n\r\n\t\t// If already found an intersection don't need to check for any more.\r\n\t\tif (polylineIntersects) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlen = points.length;\r\n\t\tfirstPoint = points[0];\r\n\t\tlastPoint = points[len - 1];\r\n\t\tmaxIndex = len - 2;\r\n\r\n\t\t// Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)\r\n\t\treturn this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Control.Draw\r\n * @aka L.Draw\r\n */\r\nL.Control.Draw = L.Control.extend({\r\n\r\n\t// Options\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tdraw: {},\r\n\t\tedit: false\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\t// Initializes draw control, toolbars from the options\r\n\tinitialize: function (options) {\r\n\t\tif (L.version < '0.7') {\r\n\t\t\tthrow new Error('Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/');\r\n\t\t}\r\n\r\n\t\tL.Control.prototype.initialize.call(this, options);\r\n\r\n\t\tvar toolbar;\r\n\r\n\t\tthis._toolbars = {};\r\n\r\n\t\t// Initialize toolbars\r\n\t\tif (L.DrawToolbar && this.options.draw) {\r\n\t\t\ttoolbar = new L.DrawToolbar(this.options.draw);\r\n\r\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE] = toolbar;\r\n\r\n\t\t\t// Listen for when toolbar is enabled\r\n\t\t\tthis._toolbars[L.DrawToolbar.TYPE].on('enable', this._toolbarEnabled, this);\r\n\t\t}\r\n\r\n\t\tif (L.EditToolbar && this.options.edit) {\r\n\t\t\ttoolbar = new L.EditToolbar(this.options.edit);\r\n\r\n\t\t\tthis._toolbars[L.EditToolbar.TYPE] = toolbar;\r\n\r\n\t\t\t// Listen for when toolbar is enabled\r\n\t\t\tthis._toolbars[L.EditToolbar.TYPE].on('enable', this._toolbarEnabled, this);\r\n\t\t}\r\n\t\tL.toolbar = this; //set global var for editing the toolbar\r\n\t},\r\n\r\n\t// @method onAdd(): container\r\n\t// Adds the toolbar container to the map\r\n\tonAdd: function (map) {\r\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw'),\r\n\t\t\taddedTopClass = false,\r\n\t\t\ttopClassName = 'leaflet-draw-toolbar-top',\r\n\t\t\ttoolbarContainer;\r\n\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\r\n\t\t\t\ttoolbarContainer = this._toolbars[toolbarId].addToolbar(map);\r\n\r\n\t\t\t\tif (toolbarContainer) {\r\n\t\t\t\t\t// Add class to the first toolbar to remove the margin\r\n\t\t\t\t\tif (!addedTopClass) {\r\n\t\t\t\t\t\tif (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {\r\n\t\t\t\t\t\t\tL.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\taddedTopClass = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontainer.appendChild(toolbarContainer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method onRemove(): void\r\n\t// Removes the toolbars from the map toolbar container\r\n\tonRemove: function () {\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars.hasOwnProperty(toolbarId)) {\r\n\t\t\t\tthis._toolbars[toolbarId].removeToolbar();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// @method setDrawingOptions(options): void\r\n\t// Sets options to all toolbar instances\r\n\tsetDrawingOptions: function (options) {\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars[toolbarId] instanceof L.DrawToolbar) {\r\n\t\t\t\tthis._toolbars[toolbarId].setOptions(options);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_toolbarEnabled: function (e) {\r\n\t\tvar enabledToolbar = e.target;\r\n\r\n\t\tfor (var toolbarId in this._toolbars) {\r\n\t\t\tif (this._toolbars[toolbarId] !== enabledToolbar) {\r\n\t\t\t\tthis._toolbars[toolbarId].disable();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tdrawControlTooltips: true,\r\n\tdrawControl: false\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.drawControl) {\r\n\t\tthis.drawControl = new L.Control.Draw();\r\n\t\tthis.addControl(this.drawControl);\r\n\t}\r\n});\r\n","/**\r\n * @class L.Draw.Toolbar\r\n * @aka Toolbar\r\n *\r\n * The toolbar class of the API — it is used to create the ui\r\n * This will be depreciated\r\n *\r\n * @example\r\n *\r\n * ```js\r\n *    var toolbar = L.Toolbar();\r\n *    toolbar.addToolbar(map);\r\n * ```\r\n *\r\n * ### Disabling a toolbar\r\n *\r\n * If you do not want a particular toolbar in your app you can turn it off by setting the toolbar to false.\r\n *\r\n * ```js\r\n *      var drawControl = new L.Control.Draw({\r\n *          draw: false,\r\n *          edit: {\r\n *              featureGroup: editableLayers\r\n *          }\r\n *      });\r\n * ```\r\n *\r\n * ### Disabling a toolbar item\r\n *\r\n * If you want to turn off a particular toolbar item, set it to false. The following disables drawing polygons and\r\n * markers. It also turns off the ability to edit layers.\r\n *\r\n * ```js\r\n *      var drawControl = new L.Control.Draw({\r\n *          draw: {\r\n *              polygon: false,\r\n *              marker: false\r\n *          },\r\n *          edit: {\r\n *              featureGroup: editableLayers,\r\n *              edit: false\r\n *          }\r\n *      });\r\n * ```\r\n */\r\nL.Toolbar = L.Class.extend({\r\n\t// @section Methods for modifying the toolbar\r\n\r\n\t// @method initialize(options): void\r\n\t// Toolbar constructor\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._modes = {};\r\n\t\tthis._actionButtons = [];\r\n\t\tthis._activeMode = null;\r\n\r\n\t\tvar version = L.version.split('.');\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.Toolbar.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.Toolbar.include(L.Mixin.Events);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method enabled(): boolean\r\n\t// Gets a true/false of whether the toolbar is enabled\r\n\tenabled: function () {\r\n\t\treturn this._activeMode !== null;\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disables the toolbar\r\n\tdisable: function () {\r\n\t\tif (!this.enabled()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._activeMode.handler.disable();\r\n\t},\r\n\r\n\t// @method addToolbar(map): L.DomUtil\r\n\t// Adds the toolbar to the map and returns the toolbar dom element\r\n\taddToolbar: function (map) {\r\n\t\tvar container = L.DomUtil.create('div', 'leaflet-draw-section'),\r\n\t\t\tbuttonIndex = 0,\r\n\t\t\tbuttonClassPrefix = this._toolbarClass || '',\r\n\t\t\tmodeHandlers = this.getModeHandlers(map),\r\n\t\t\ti;\r\n\r\n\t\tthis._toolbarContainer = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');\r\n\t\tthis._map = map;\r\n\r\n\t\tfor (i = 0; i < modeHandlers.length; i++) {\r\n\t\t\tif (modeHandlers[i].enabled) {\r\n\t\t\t\tthis._initModeHandler(\r\n\t\t\t\t\tmodeHandlers[i].handler,\r\n\t\t\t\t\tthis._toolbarContainer,\r\n\t\t\t\t\tbuttonIndex++,\r\n\t\t\t\t\tbuttonClassPrefix,\r\n\t\t\t\t\tmodeHandlers[i].title\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if no buttons were added, do not add the toolbar\r\n\t\tif (!buttonIndex) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Save button index of the last button, -1 as we would have ++ after the last button\r\n\t\tthis._lastButtonIndex = --buttonIndex;\r\n\r\n\t\t// Create empty actions part of the toolbar\r\n\t\tthis._actionsContainer = L.DomUtil.create('ul', 'leaflet-draw-actions');\r\n\r\n\t\t// Add draw and cancel containers to the control container\r\n\t\tcontainer.appendChild(this._toolbarContainer);\r\n\t\tcontainer.appendChild(this._actionsContainer);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method removeToolbar(): void\r\n\t// Removes the toolbar and drops the handler event listeners\r\n\tremoveToolbar: function () {\r\n\t\t// Dispose each handler\r\n\t\tfor (var handlerId in this._modes) {\r\n\t\t\tif (this._modes.hasOwnProperty(handlerId)) {\r\n\t\t\t\t// Unbind handler button\r\n\t\t\t\tthis._disposeButton(\r\n\t\t\t\t\tthis._modes[handlerId].button,\r\n\t\t\t\t\tthis._modes[handlerId].handler.enable,\r\n\t\t\t\t\tthis._modes[handlerId].handler\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Make sure is disabled\r\n\t\t\t\tthis._modes[handlerId].handler.disable();\r\n\r\n\t\t\t\t// Unbind handler\r\n\t\t\t\tthis._modes[handlerId].handler\r\n\t\t\t\t\t.off('enabled', this._handlerActivated, this)\r\n\t\t\t\t\t.off('disabled', this._handlerDeactivated, this);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._modes = {};\r\n\r\n\t\t// Dispose the actions toolbar\r\n\t\tfor (var i = 0, l = this._actionButtons.length; i < l; i++) {\r\n\t\t\tthis._disposeButton(\r\n\t\t\t\tthis._actionButtons[i].button,\r\n\t\t\t\tthis._actionButtons[i].callback,\r\n\t\t\t\tthis\r\n\t\t\t);\r\n\t\t}\r\n\t\tthis._actionButtons = [];\r\n\t\tthis._actionsContainer = null;\r\n\t},\r\n\r\n\t_initModeHandler: function (handler, container, buttonIndex, classNamePredix, buttonTitle) {\r\n\t\tvar type = handler.type;\r\n\r\n\t\tthis._modes[type] = {};\r\n\r\n\t\tthis._modes[type].handler = handler;\r\n\r\n\t\tthis._modes[type].button = this._createButton({\r\n\t\t\ttype: type,\r\n\t\t\ttitle: buttonTitle,\r\n\t\t\tclassName: classNamePredix + '-' + type,\r\n\t\t\tcontainer: container,\r\n\t\t\tcallback: this._modes[type].handler.enable,\r\n\t\t\tcontext: this._modes[type].handler\r\n\t\t});\r\n\r\n\t\tthis._modes[type].buttonIndex = buttonIndex;\r\n\r\n\t\tthis._modes[type].handler\r\n\t\t\t.on('enabled', this._handlerActivated, this)\r\n\t\t\t.on('disabled', this._handlerDeactivated, this);\r\n\t},\r\n\r\n\t/* Detect iOS based on browser User Agent, based on:\r\n\t * http://stackoverflow.com/a/9039885 */\r\n\t_detectIOS: function () {\r\n\t\tvar iOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);\r\n\t\treturn iOS;\r\n\t},\r\n\r\n\t_createButton: function (options) {\r\n\r\n\t\tvar link = L.DomUtil.create('a', options.className || '', options.container);\r\n\t\t// Screen reader tag\r\n\t\tvar sr = L.DomUtil.create('span', 'sr-only', options.container);\r\n\r\n\t\tlink.href = '#';\r\n\t\tlink.appendChild(sr);\r\n\r\n\t\tif (options.title) {\r\n\t\t\tlink.title = options.title;\r\n\t\t\tsr.innerHTML = options.title;\r\n\t\t}\r\n\r\n\t\tif (options.text) {\r\n\t\t\tlink.innerHTML = options.text;\r\n\t\t\tsr.innerHTML = options.text;\r\n\t\t}\r\n\r\n\t\t/* iOS does not use click events */\r\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\r\n\r\n\t\tL.DomEvent\r\n\t\t\t.on(link, 'click', L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, 'mousedown', L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, 'dblclick', L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, 'touchstart', L.DomEvent.stopPropagation)\r\n\t\t\t.on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t\t.on(link, buttonEvent, options.callback, options.context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_disposeButton: function (button, callback) {\r\n\t\t/* iOS does not use click events */\r\n\t\tvar buttonEvent = this._detectIOS() ? 'touchstart' : 'click';\r\n\r\n\t\tL.DomEvent\r\n\t\t\t.off(button, 'click', L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, 'mousedown', L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, 'dblclick', L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, 'touchstart', L.DomEvent.stopPropagation)\r\n\t\t\t.off(button, 'click', L.DomEvent.preventDefault)\r\n\t\t\t.off(button, buttonEvent, callback);\r\n\t},\r\n\r\n\t_handlerActivated: function (e) {\r\n\t\t// Disable active mode (if present)\r\n\t\tthis.disable();\r\n\r\n\t\t// Cache new active feature\r\n\t\tthis._activeMode = this._modes[e.handler];\r\n\r\n\t\tL.DomUtil.addClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\r\n\r\n\t\tthis._showActionsToolbar();\r\n\r\n\t\tthis.fire('enable');\r\n\t},\r\n\r\n\t_handlerDeactivated: function () {\r\n\t\tthis._hideActionsToolbar();\r\n\r\n\t\tL.DomUtil.removeClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');\r\n\r\n\t\tthis._activeMode = null;\r\n\r\n\t\tthis.fire('disable');\r\n\t},\r\n\r\n\t_createActions: function (handler) {\r\n\t\tvar container = this._actionsContainer,\r\n\t\t\tbuttons = this.getActions(handler),\r\n\t\t\tl = buttons.length,\r\n\t\t\tli, di, dl, button;\r\n\r\n\t\t// Dispose the actions toolbar (todo: dispose only not used buttons)\r\n\t\tfor (di = 0, dl = this._actionButtons.length; di < dl; di++) {\r\n\t\t\tthis._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);\r\n\t\t}\r\n\t\tthis._actionButtons = [];\r\n\r\n\t\t// Remove all old buttons\r\n\t\twhile (container.firstChild) {\r\n\t\t\tcontainer.removeChild(container.firstChild);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\tif ('enabled' in buttons[i] && !buttons[i].enabled) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tli = L.DomUtil.create('li', '', container);\r\n\r\n\t\t\tbutton = this._createButton({\r\n\t\t\t\ttitle: buttons[i].title,\r\n\t\t\t\ttext: buttons[i].text,\r\n\t\t\t\tcontainer: li,\r\n\t\t\t\tcallback: buttons[i].callback,\r\n\t\t\t\tcontext: buttons[i].context\r\n\t\t\t});\r\n\r\n\t\t\tthis._actionButtons.push({\r\n\t\t\t\tbutton: button,\r\n\t\t\t\tcallback: buttons[i].callback\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_showActionsToolbar: function () {\r\n\t\tvar buttonIndex = this._activeMode.buttonIndex,\r\n\t\t\tlastButtonIndex = this._lastButtonIndex,\r\n\t\t\ttoolbarPosition = this._activeMode.button.offsetTop - 1;\r\n\r\n\t\t// Recreate action buttons on every click\r\n\t\tthis._createActions(this._activeMode.handler);\r\n\r\n\t\t// Correctly position the cancel button\r\n\t\tthis._actionsContainer.style.top = toolbarPosition + 'px';\r\n\r\n\t\tif (buttonIndex === 0) {\r\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\r\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-top');\r\n\t\t}\r\n\r\n\t\tif (buttonIndex === lastButtonIndex) {\r\n\t\t\tL.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\r\n\t\t\tL.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\r\n\t\t}\r\n\r\n\t\tthis._actionsContainer.style.display = 'block';\r\n\t\tthis._map.fire(L.Draw.Event.TOOLBAROPENED);\r\n\t},\r\n\r\n\t_hideActionsToolbar: function () {\r\n\t\tthis._actionsContainer.style.display = 'none';\r\n\r\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');\r\n\t\tL.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');\r\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-top');\r\n\t\tL.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-bottom');\r\n\t\tthis._map.fire(L.Draw.Event.TOOLBARCLOSED);\r\n\t}\r\n});\r\n","L.Draw = L.Draw || {};\r\n/**\r\n * @class L.Draw.Tooltip\r\n * @aka Tooltip\r\n *\r\n * The tooltip class — it is used to display the tooltip while drawing\r\n * This will be depreciated\r\n *\r\n * @example\r\n *\r\n * ```js\r\n *    var tooltip = L.Draw.Tooltip();\r\n * ```\r\n *\r\n */\r\nL.Draw.Tooltip = L.Class.extend({\r\n\r\n\t// @section Methods for modifying draw state\r\n\r\n\t// @method initialize(map): void\r\n\t// Tooltip constructor\r\n\tinitialize: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._popupPane = map._panes.popupPane;\r\n\t\tthis._visible = false;\r\n\r\n\t\tthis._container = map.options.drawControlTooltips ?\r\n\t\t\tL.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;\r\n\t\tthis._singleLineLabel = false;\r\n\r\n\t\tthis._map.on('mouseout', this._onMouseOut, this);\r\n\t},\r\n\r\n\t// @method dispose(): void\r\n\t// Remove Tooltip DOM and unbind events\r\n\tdispose: function () {\r\n\t\tthis._map.off('mouseout', this._onMouseOut, this);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._popupPane.removeChild(this._container);\r\n\t\t\tthis._container = null;\r\n\t\t}\r\n\t},\r\n\r\n\t// @method updateContent(labelText): this\r\n\t// Changes the tooltip text to string in function call\r\n\tupdateContent: function (labelText) {\r\n\t\tif (!this._container) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tlabelText.subtext = labelText.subtext || '';\r\n\r\n\t\t// update the vertical position (only if changed)\r\n\t\tif (labelText.subtext.length === 0 && !this._singleLineLabel) {\r\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');\r\n\t\t\tthis._singleLineLabel = true;\r\n\t\t}\r\n\t\telse if (labelText.subtext.length > 0 && this._singleLineLabel) {\r\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');\r\n\t\t\tthis._singleLineLabel = false;\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML =\r\n\t\t\t(labelText.subtext.length > 0 ?\r\n\t\t\t\t'<span class=\"leaflet-draw-tooltip-subtext\">' + labelText.subtext + '</span>' + '<br />' : '') +\r\n\t\t\t'<span>' + labelText.text + '</span>';\r\n\r\n\t\tif (!labelText.text && !labelText.subtext) {\r\n\t\t\tthis._visible = false;\r\n\t\t\tthis._container.style.visibility = 'hidden';\r\n\t\t} else {\r\n\t\t\tthis._visible = true;\r\n\t\t\tthis._container.style.visibility = 'inherit';\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method updatePosition(latlng): this\r\n\t// Changes the location of the tooltip\r\n\tupdatePosition: function (latlng) {\r\n\t\tvar pos = this._map.latLngToLayerPoint(latlng),\r\n\t\t\ttooltipContainer = this._container;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tif (this._visible) {\r\n\t\t\t\ttooltipContainer.style.visibility = 'inherit';\r\n\t\t\t}\r\n\t\t\tL.DomUtil.setPosition(tooltipContainer, pos);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method showAsError(): this\r\n\t// Applies error class to tooltip\r\n\tshowAsError: function () {\r\n\t\tif (this._container) {\r\n\t\t\tL.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method removeError(): this\r\n\t// Removes the error class from the tooltip\r\n\tremoveError: function () {\r\n\t\tif (this._container) {\r\n\t\t\tL.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_onMouseOut: function () {\r\n\t\tif (this._container) {\r\n\t\t\tthis._container.style.visibility = 'hidden';\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.DrawToolbar\r\n * @aka Toolbar\r\n */\r\nL.DrawToolbar = L.Toolbar.extend({\r\n\r\n\tstatics: {\r\n\t\tTYPE: 'draw'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tpolyline: {},\r\n\t\tpolygon: {},\r\n\t\trectangle: {},\r\n\t\tcircle: {},\r\n\t\tmarker: {},\r\n\t\tcirclemarker: {}\r\n\t},\r\n\r\n\t// @method initialize(): void\r\n\tinitialize: function (options) {\r\n\t\t// Ensure that the options are merged correctly since L.extend is only shallow\r\n\t\tfor (var type in this.options) {\r\n\t\t\tif (this.options.hasOwnProperty(type)) {\r\n\t\t\t\tif (options[type]) {\r\n\t\t\t\t\toptions[type] = L.extend({}, this.options[type], options[type]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._toolbarClass = 'leaflet-draw-draw';\r\n\t\tL.Toolbar.prototype.initialize.call(this, options);\r\n\t},\r\n\r\n\t// @method getModeHandlers(): object\r\n\t// Get mode handlers information\r\n\tgetModeHandlers: function (map) {\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.polyline,\r\n\t\t\t\thandler: new L.Draw.Polyline(map, this.options.polyline),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polyline\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.polygon,\r\n\t\t\t\thandler: new L.Draw.Polygon(map, this.options.polygon),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.polygon\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.rectangle,\r\n\t\t\t\thandler: new L.Draw.Rectangle(map, this.options.rectangle),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.rectangle\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.circle,\r\n\t\t\t\thandler: new L.Draw.Circle(map, this.options.circle),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.circle\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.marker,\r\n\t\t\t\thandler: new L.Draw.Marker(map, this.options.marker),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.marker\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.circlemarker,\r\n\t\t\t\thandler: new L.Draw.CircleMarker(map, this.options.circlemarker),\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.buttons.circlemarker\r\n\t\t\t}\r\n\t\t];\r\n\t},\r\n\r\n\t// @method getActions(): object\r\n\t// Get action information\r\n\tgetActions: function (handler) {\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tenabled: handler.completeShape,\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.finish.title,\r\n\t\t\t\ttext: L.drawLocal.draw.toolbar.finish.text,\r\n\t\t\t\tcallback: handler.completeShape,\r\n\t\t\t\tcontext: handler\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: handler.deleteLastVertex,\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.undo.title,\r\n\t\t\t\ttext: L.drawLocal.draw.toolbar.undo.text,\r\n\t\t\t\tcallback: handler.deleteLastVertex,\r\n\t\t\t\tcontext: handler\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.draw.toolbar.actions.title,\r\n\t\t\t\ttext: L.drawLocal.draw.toolbar.actions.text,\r\n\t\t\t\tcallback: this.disable,\r\n\t\t\t\tcontext: this\r\n\t\t\t}\r\n\t\t];\r\n\t},\r\n\r\n\t// @method setOptions(): void\r\n\t// Sets the options to the toolbar\r\n\tsetOptions: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tfor (var type in this._modes) {\r\n\t\t\tif (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {\r\n\t\t\t\tthis._modes[type].handler.setOptions(options[type]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n","/*L.Map.mergeOptions({\r\n editControl: true\r\n });*/\r\n/**\r\n * @class L.EditToolbar\r\n * @aka EditToolbar\r\n */\r\nL.EditToolbar = L.Toolbar.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'edit'\r\n\t},\r\n\r\n\toptions: {\r\n\t\tedit: {\r\n\t\t\tselectedPathOptions: {\r\n\t\t\t\tdashArray: '10, 10',\r\n\r\n\t\t\t\tfill: true,\r\n\t\t\t\tfillColor: '#fe57a1',\r\n\t\t\t\tfillOpacity: 0.1,\r\n\r\n\t\t\t\t// Whether to user the existing layers color\r\n\t\t\t\tmaintainColor: false\r\n\t\t\t}\r\n\t\t},\r\n\t\tremove: {},\r\n\t\tpoly: null,\r\n\t\tfeatureGroup: null /* REQUIRED! TODO: perhaps if not set then all layers on the map are selectable? */\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (options) {\r\n\t\t// Need to set this manually since null is an acceptable value here\r\n\t\tif (options.edit) {\r\n\t\t\tif (typeof options.edit.selectedPathOptions === 'undefined') {\r\n\t\t\t\toptions.edit.selectedPathOptions = this.options.edit.selectedPathOptions;\r\n\t\t\t}\r\n\t\t\toptions.edit.selectedPathOptions = L.extend({}, this.options.edit.selectedPathOptions, options.edit.selectedPathOptions);\r\n\t\t}\r\n\r\n\t\tif (options.remove) {\r\n\t\t\toptions.remove = L.extend({}, this.options.remove, options.remove);\r\n\t\t}\r\n\r\n\t\tif (options.poly) {\r\n\t\t\toptions.poly = L.extend({}, this.options.poly, options.poly);\r\n\t\t}\r\n\r\n\t\tthis._toolbarClass = 'leaflet-draw-edit';\r\n\t\tL.Toolbar.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._selectedFeatureCount = 0;\r\n\t},\r\n\r\n\t// @method getModeHandlers(): object\r\n\t// Get mode handlers information\r\n\tgetModeHandlers: function (map) {\r\n\t\tvar featureGroup = this.options.featureGroup;\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.edit,\r\n\t\t\t\thandler: new L.EditToolbar.Edit(map, {\r\n\t\t\t\t\tfeatureGroup: featureGroup,\r\n\t\t\t\t\tselectedPathOptions: this.options.edit.selectedPathOptions,\r\n\t\t\t\t\tpoly: this.options.poly\r\n\t\t\t\t}),\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.edit\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tenabled: this.options.remove,\r\n\t\t\t\thandler: new L.EditToolbar.Delete(map, {\r\n\t\t\t\t\tfeatureGroup: featureGroup\r\n\t\t\t\t}),\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.buttons.remove\r\n\t\t\t}\r\n\t\t];\r\n\t},\r\n\r\n\t// @method getActions(): object\r\n\t// Get actions information\r\n\tgetActions: function (handler) {\r\n\t\tvar actions = [\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.save.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.save.text,\r\n\t\t\t\tcallback: this._save,\r\n\t\t\t\tcontext: this\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.cancel.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.cancel.text,\r\n\t\t\t\tcallback: this.disable,\r\n\t\t\t\tcontext: this\r\n\t\t\t}\r\n\t\t];\r\n\r\n\t\tif (handler.removeAllLayers) {\r\n\t\t\tactions.push({\r\n\t\t\t\ttitle: L.drawLocal.edit.toolbar.actions.clearAll.title,\r\n\t\t\t\ttext: L.drawLocal.edit.toolbar.actions.clearAll.text,\r\n\t\t\t\tcallback: this._clearAllLayers,\r\n\t\t\t\tcontext: this\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn actions;\r\n\t},\r\n\r\n\t// @method addToolbar(map): L.DomUtil\r\n\t// Adds the toolbar to the map\r\n\taddToolbar: function (map) {\r\n\t\tvar container = L.Toolbar.prototype.addToolbar.call(this, map);\r\n\r\n\t\tthis._checkDisabled();\r\n\r\n\t\tthis.options.featureGroup.on('layeradd layerremove', this._checkDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\t// @method removeToolbar(): void\r\n\t// Removes the toolbar from the map\r\n\tremoveToolbar: function () {\r\n\t\tthis.options.featureGroup.off('layeradd layerremove', this._checkDisabled, this);\r\n\r\n\t\tL.Toolbar.prototype.removeToolbar.call(this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disables the toolbar\r\n\tdisable: function () {\r\n\t\tif (!this.enabled()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._activeMode.handler.revertLayers();\r\n\r\n\t\tL.Toolbar.prototype.disable.call(this);\r\n\t},\r\n\r\n\t_save: function () {\r\n\t\tthis._activeMode.handler.save();\r\n\t\tif (this._activeMode) {\r\n\t\t\tthis._activeMode.handler.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_clearAllLayers: function () {\r\n\t\tthis._activeMode.handler.removeAllLayers();\r\n\t\tif (this._activeMode) {\r\n\t\t\tthis._activeMode.handler.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_checkDisabled: function () {\r\n\t\tvar featureGroup = this.options.featureGroup,\r\n\t\t\thasLayers = featureGroup.getLayers().length !== 0,\r\n\t\t\tbutton;\r\n\r\n\t\tif (this.options.edit) {\r\n\t\t\tbutton = this._modes[L.EditToolbar.Edit.TYPE].button;\r\n\r\n\t\t\tif (hasLayers) {\r\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\r\n\t\t\t}\r\n\r\n\t\t\tbutton.setAttribute(\r\n\t\t\t\t'title',\r\n\t\t\t\thasLayers ?\r\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.edit\r\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.editDisabled\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (this.options.remove) {\r\n\t\t\tbutton = this._modes[L.EditToolbar.Delete.TYPE].button;\r\n\r\n\t\t\tif (hasLayers) {\r\n\t\t\t\tL.DomUtil.removeClass(button, 'leaflet-disabled');\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(button, 'leaflet-disabled');\r\n\t\t\t}\r\n\r\n\t\t\tbutton.setAttribute(\r\n\t\t\t\t'title',\r\n\t\t\t\thasLayers ?\r\n\t\t\t\t\tL.drawLocal.edit.toolbar.buttons.remove\r\n\t\t\t\t\t: L.drawLocal.edit.toolbar.buttons.removeDisabled\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n});\r\n","/**\r\n * @class L.EditToolbar.Edit\r\n * @aka EditToolbar.Edit\r\n */\r\nL.EditToolbar.Edit = L.Handler.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'edit'\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Handler.prototype.initialize.call(this, map);\r\n\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\t// Store the selectable layer group for ease of access\r\n\t\tthis._featureGroup = options.featureGroup;\r\n\r\n\t\tif (!(this._featureGroup instanceof L.FeatureGroup)) {\r\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\r\n\t\t}\r\n\r\n\t\tthis._uneditedLayerProps = {};\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.EditToolbar.Edit.TYPE;\r\n\r\n\t\tvar version = L.version.split('.');\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.EditToolbar.Edit.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.EditToolbar.Edit.include(L.Mixin.Events);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enable the edit toolbar\r\n\tenable: function () {\r\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.fire('enabled', {handler: this.type});\r\n\t\t//this disable other handlers\r\n\r\n\t\tthis._map.fire(L.Draw.Event.EDITSTART, {handler: this.type});\r\n\t\t//allow drawLayer to be updated before beginning edition.\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\t\tthis._featureGroup\r\n\t\t\t.on('layeradd', this._enableLayerEdit, this)\r\n\t\t\t.on('layerremove', this._disableLayerEdit, this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disable the edit toolbar\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._featureGroup\r\n\t\t\t.off('layeradd', this._enableLayerEdit, this)\r\n\t\t\t.off('layerremove', this._disableLayerEdit, this);\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\t\tthis._map.fire(L.Draw.Event.EDITSTOP, {handler: this.type});\r\n\t\tthis.fire('disabled', {handler: this.type});\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks for this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._featureGroup.eachLayer(this._enableLayerEdit, this);\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\t\t\tthis._tooltip.updateContent({\r\n\t\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\r\n\t\t\t});\r\n\r\n\t\t\t// Quickly access the tooltip to update for intersection checking\r\n\t\t\tmap._editTooltip = this._tooltip;\r\n\r\n\t\t\tthis._updateTooltip();\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.on('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.on('touchmove', this._onMouseMove, this)\r\n\t\t\t\t.on('MSPointerMove', this._onMouseMove, this)\r\n\t\t\t\t.on(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks for this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\t// Clean up selected layers.\r\n\t\t\tthis._featureGroup.eachLayer(this._disableLayerEdit, this);\r\n\t\t\tthis._map._editTooltip.dispose();\r\n\t\t\tthis._map._editTooltip = null;\r\n\t\t\t// Clear the backups of the original layers\r\n\t\t\tthis._uneditedLayerProps = {};\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tthis._map\r\n\t\t\t\t.off('mousemove', this._onMouseMove, this)\r\n\t\t\t\t.off('touchmove', this._onMouseMove, this)\r\n\t\t\t\t.off('MSPointerMove', this._onMouseMove, this)\r\n\t\t\t\t.off(L.Draw.Event.EDITVERTEX, this._updateTooltip, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method revertLayers(): void\r\n\t// Revert each layer's geometry changes\r\n\trevertLayers: function () {\r\n\t\tthis._featureGroup.eachLayer(function (layer) {\r\n\t\t\tthis._revertLayer(layer);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t// @method save(): void\r\n\t// Save the layer geometries\r\n\tsave: function () {\r\n\t\tvar editedLayers = new L.LayerGroup();\r\n\t\tthis._featureGroup.eachLayer(function (layer) {\r\n\t\t\tif (layer.edited) {\r\n\t\t\t\teditedLayers.addLayer(layer);\r\n\t\t\t\tlayer.edited = false;\r\n\t\t\t}\r\n\t\t});\r\n\t\tthis._map.fire(L.Draw.Event.EDITED, {layers: editedLayers});\r\n\t},\r\n\r\n\t_backupLayer: function (layer) {\r\n\t\tvar id = L.Util.stamp(layer);\r\n\r\n\t\tif (!this._uneditedLayerProps[id]) {\r\n\t\t\t// Polyline, Polygon or Rectangle\r\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs())\r\n\t\t\t\t};\r\n\t\t\t} else if (layer instanceof L.Circle) {\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng()),\r\n\t\t\t\t\tradius: layer.getRadius()\r\n\t\t\t\t};\r\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker\r\n\t\t\t\tthis._uneditedLayerProps[id] = {\r\n\t\t\t\t\tlatlng: L.LatLngUtil.cloneLatLng(layer.getLatLng())\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getTooltipText: function () {\r\n\t\treturn ({\r\n\t\t\ttext: L.drawLocal.edit.handlers.edit.tooltip.text,\r\n\t\t\tsubtext: L.drawLocal.edit.handlers.edit.tooltip.subtext\r\n\t\t});\r\n\t},\r\n\r\n\t_updateTooltip: function () {\r\n\t\tthis._tooltip.updateContent(this._getTooltipText());\r\n\t},\r\n\r\n\t_revertLayer: function (layer) {\r\n\t\tvar id = L.Util.stamp(layer);\r\n\t\tlayer.edited = false;\r\n\t\tif (this._uneditedLayerProps.hasOwnProperty(id)) {\r\n\t\t\t// Polyline, Polygon or Rectangle\r\n\t\t\tif (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {\r\n\t\t\t\tlayer.setLatLngs(this._uneditedLayerProps[id].latlngs);\r\n\t\t\t} else if (layer instanceof L.Circle) {\r\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\r\n\t\t\t\tlayer.setRadius(this._uneditedLayerProps[id].radius);\r\n\t\t\t} else if (layer instanceof L.Marker || layer instanceof L.CircleMarker) { // Marker or CircleMarker\r\n\t\t\t\tlayer.setLatLng(this._uneditedLayerProps[id].latlng);\r\n\t\t\t}\r\n\r\n\t\t\tlayer.fire('revert-edited', {layer: layer});\r\n\t\t}\r\n\t},\r\n\r\n\t_enableLayerEdit: function (e) {\r\n\t\tvar layer = e.layer || e.target || e,\r\n\t\t\tpathOptions, poly;\r\n\r\n\t\t// Back up this layer (if haven't before)\r\n\t\tthis._backupLayer(layer);\r\n\r\n\t\tif (this.options.poly) {\r\n\t\t\tpoly = L.Util.extend({}, this.options.poly);\r\n\t\t\tlayer.options.poly = poly;\r\n\t\t}\r\n\r\n\t\t// Set different style for editing mode\r\n\t\tif (this.options.selectedPathOptions) {\r\n\t\t\tpathOptions = L.Util.extend({}, this.options.selectedPathOptions);\r\n\r\n\t\t\t// Use the existing color of the layer\r\n\t\t\tif (pathOptions.maintainColor) {\r\n\t\t\t\tpathOptions.color = layer.options.color;\r\n\t\t\t\tpathOptions.fillColor = layer.options.fillColor;\r\n\t\t\t}\r\n\r\n\t\t\tlayer.options.original = L.extend({}, layer.options);\r\n\t\t\tlayer.options.editing = pathOptions;\r\n\r\n\t\t}\r\n\r\n\t\tif (layer instanceof L.Marker) {\r\n\t\t\tif (layer.editing) {\r\n\t\t\t\tlayer.editing.enable();\r\n\t\t\t}\r\n\t\t\tlayer.dragging.enable();\r\n\t\t\tlayer\r\n\t\t\t\t.on('dragend', this._onMarkerDragEnd)\r\n\t\t\t\t// #TODO: remove when leaflet finally fixes their draggable so it's touch friendly again.\r\n\t\t\t\t.on('touchmove', this._onTouchMove, this)\r\n\t\t\t\t.on('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t\t.on('touchend', this._onMarkerDragEnd, this)\r\n\t\t\t\t.on('MSPointerUp', this._onMarkerDragEnd, this);\r\n\t\t} else {\r\n\t\t\tlayer.editing.enable();\r\n\t\t}\r\n\t},\r\n\r\n\t_disableLayerEdit: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.edited = false;\r\n\t\tif (layer.editing) {\r\n\t\t\tlayer.editing.disable();\r\n\t\t}\r\n\r\n\t\tdelete layer.options.editing;\r\n\t\tdelete layer.options.original;\r\n\t\t// Reset layer styles to that of before select\r\n\t\tif (this._selectedPathOptions) {\r\n\t\t\tif (layer instanceof L.Marker) {\r\n\t\t\t\tthis._toggleMarkerHighlight(layer);\r\n\t\t\t} else {\r\n\t\t\t\t// reset the layer style to what is was before being selected\r\n\t\t\t\tlayer.setStyle(layer.options.previousOptions);\r\n\t\t\t\t// remove the cached options for the layer object\r\n\t\t\t\tdelete layer.options.previousOptions;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (layer instanceof L.Marker) {\r\n\t\t\tlayer.dragging.disable();\r\n\t\t\tlayer\r\n\t\t\t\t.off('dragend', this._onMarkerDragEnd, this)\r\n\t\t\t\t.off('touchmove', this._onTouchMove, this)\r\n\t\t\t\t.off('MSPointerMove', this._onTouchMove, this)\r\n\t\t\t\t.off('touchend', this._onMarkerDragEnd, this)\r\n\t\t\t\t.off('MSPointerUp', this._onMarkerDragEnd, this);\r\n\t\t} else {\r\n\t\t\tlayer.editing.disable();\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tthis._tooltip.updatePosition(e.latlng);\r\n\t},\r\n\r\n\t_onMarkerDragEnd: function (e) {\r\n\t\tvar layer = e.target;\r\n\t\tlayer.edited = true;\r\n\t\tthis._map.fire(L.Draw.Event.EDITMOVE, {layer: layer});\r\n\t},\r\n\r\n\t_onTouchMove: function (e) {\r\n\t\tvar touchEvent = e.originalEvent.changedTouches[0],\r\n\t\t\tlayerPoint = this._map.mouseEventToLayerPoint(touchEvent),\r\n\t\t\tlatlng = this._map.layerPointToLatLng(layerPoint);\r\n\t\te.target.setLatLng(latlng);\r\n\t},\r\n\r\n\t_hasAvailableLayers: function () {\r\n\t\treturn this._featureGroup.getLayers().length !== 0;\r\n\t}\r\n});\r\n","/**\r\n * @class L.EditToolbar.Delete\r\n * @aka EditToolbar.Delete\r\n */\r\nL.EditToolbar.Delete = L.Handler.extend({\r\n\tstatics: {\r\n\t\tTYPE: 'remove' // not delete as delete is reserved in js\r\n\t},\r\n\r\n\t// @method intialize(): void\r\n\tinitialize: function (map, options) {\r\n\t\tL.Handler.prototype.initialize.call(this, map);\r\n\r\n\t\tL.Util.setOptions(this, options);\r\n\r\n\t\t// Store the selectable layer group for ease of access\r\n\t\tthis._deletableLayers = this.options.featureGroup;\r\n\r\n\t\tif (!(this._deletableLayers instanceof L.FeatureGroup)) {\r\n\t\t\tthrow new Error('options.featureGroup must be a L.FeatureGroup');\r\n\t\t}\r\n\r\n\t\t// Save the type so super can fire, need to do this as cannot do this.TYPE :(\r\n\t\tthis.type = L.EditToolbar.Delete.TYPE;\r\n\r\n\t\tvar version = L.version.split('.');\r\n\t\t//If Version is >= 1.2.0\r\n\t\tif (parseInt(version[0], 10) === 1 && parseInt(version[1], 10) >= 2) {\r\n\t\t\tL.EditToolbar.Delete.include(L.Evented.prototype);\r\n\t\t} else {\r\n\t\t\tL.EditToolbar.Delete.include(L.Mixin.Events);\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// @method enable(): void\r\n\t// Enable the delete toolbar\r\n\tenable: function () {\r\n\t\tif (this._enabled || !this._hasAvailableLayers()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.fire('enabled', {handler: this.type});\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DELETESTART, {handler: this.type});\r\n\r\n\t\tL.Handler.prototype.enable.call(this);\r\n\r\n\t\tthis._deletableLayers\r\n\t\t\t.on('layeradd', this._enableLayerDelete, this)\r\n\t\t\t.on('layerremove', this._disableLayerDelete, this);\r\n\t},\r\n\r\n\t// @method disable(): void\r\n\t// Disable the delete toolbar\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._deletableLayers\r\n\t\t\t.off('layeradd', this._enableLayerDelete, this)\r\n\t\t\t.off('layerremove', this._disableLayerDelete, this);\r\n\r\n\t\tL.Handler.prototype.disable.call(this);\r\n\r\n\t\tthis._map.fire(L.Draw.Event.DELETESTOP, {handler: this.type});\r\n\r\n\t\tthis.fire('disabled', {handler: this.type});\r\n\t},\r\n\r\n\t// @method addHooks(): void\r\n\t// Add listener hooks to this handler\r\n\taddHooks: function () {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.getContainer().focus();\r\n\r\n\t\t\tthis._deletableLayers.eachLayer(this._enableLayerDelete, this);\r\n\t\t\tthis._deletedLayers = new L.LayerGroup();\r\n\r\n\t\t\tthis._tooltip = new L.Draw.Tooltip(this._map);\r\n\t\t\tthis._tooltip.updateContent({text: L.drawLocal.edit.handlers.remove.tooltip.text});\r\n\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method removeHooks(): void\r\n\t// Remove listener hooks from this handler\r\n\tremoveHooks: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._deletableLayers.eachLayer(this._disableLayerDelete, this);\r\n\t\t\tthis._deletedLayers = null;\r\n\r\n\t\t\tthis._tooltip.dispose();\r\n\t\t\tthis._tooltip = null;\r\n\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\t},\r\n\r\n\t// @method revertLayers(): void\r\n\t// Revert the deleted layers back to their prior state.\r\n\trevertLayers: function () {\r\n\t\t// Iterate of the deleted layers and add them back into the featureGroup\r\n\t\tthis._deletedLayers.eachLayer(function (layer) {\r\n\t\t\tthis._deletableLayers.addLayer(layer);\r\n\t\t\tlayer.fire('revert-deleted', {layer: layer});\r\n\t\t}, this);\r\n\t},\r\n\r\n\t// @method save(): void\r\n\t// Save deleted layers\r\n\tsave: function () {\r\n\t\tthis._map.fire(L.Draw.Event.DELETED, {layers: this._deletedLayers});\r\n\t},\r\n\r\n\t// @method removeAllLayers(): void\r\n\t// Remove all delateable layers\r\n\tremoveAllLayers: function () {\r\n\t\t// Iterate of the delateable layers and add remove them\r\n\t\tthis._deletableLayers.eachLayer(function (layer) {\r\n\t\t\tthis._removeLayer({layer: layer});\r\n\t\t}, this);\r\n\t\tthis.save();\r\n\t},\r\n\r\n\t_enableLayerDelete: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.on('click', this._removeLayer, this);\r\n\t},\r\n\r\n\t_disableLayerDelete: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tlayer.off('click', this._removeLayer, this);\r\n\r\n\t\t// Remove from the deleted layers so we can't accidentally revert if the user presses cancel\r\n\t\tthis._deletedLayers.removeLayer(layer);\r\n\t},\r\n\r\n\t_removeLayer: function (e) {\r\n\t\tvar layer = e.layer || e.target || e;\r\n\r\n\t\tthis._deletableLayers.removeLayer(layer);\r\n\r\n\t\tthis._deletedLayers.addLayer(layer);\r\n\r\n\t\tlayer.fire('deleted');\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tthis._tooltip.updatePosition(e.latlng);\r\n\t},\r\n\r\n\t_hasAvailableLayers: function () {\r\n\t\treturn this._deletableLayers.getLayers().length !== 0;\r\n\t}\r\n});\r\n"]}